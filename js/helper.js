const helper = {
    checkIntersectionBetweenNotRotatedRectangleAndPoint: function (
        farX, closeX,
        farY, closeY,
        pointX, pointY,
    ) {
        if (closeX <= pointX &&
            farX >= pointX &&
            closeY <= pointY &&
            farY >= pointY) {
            return true;
        } else {
            return false;
        };
    },

    getRandomColor: function () {
        let letters = '012345678ABCDEF';
        let color = '#';

        for (let i = 0; i < 6; i++) {
            color += letters[Math.floor(Math.random() * 16)];
        };

        return color;
    },

    randomIntFromInterval: function (min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min);
    },

    /*Функция для нахождения целочисленных точек между двумя точками ("x1"; "y1") и ("x2"; "y2") на основе линейной интерполяции. 
    Линейная интерполяция - это метод, который используется для нахождения промежуточных значений между двумя известными значениями
    или точками на прямой линии.*/
    getPointsBetweenTwoPoints: function (x1, y1, x2, y2) {
        /*Подготавливаем массив для точек.*/
        const points = [];
        /*Находим расстояние между x1 и x2.*/
        const dx = x2 - x1;
        /*Находим расстояние между y1 и y2.*/
        const dy = y2 - y1;
        /*Находим расстояние между двумя точками по формуле расстояния между точками на основе теоремы Пифагора:
        квадратный корень из "(x2 - x1)^2 + (y2 - y1)^2".*/
        const distance = Math.sqrt(dx * dx + dy * dy);
        /*Определяем количество шагов интерполяции, то есть количество точек между двумя точками, путем округления 
        расстояния между точками понизу.*/
        const steps = Math.floor(distance);

        /*Начинаем делать шаги интерполяции.*/
        for (let i = 0; i <= steps; i++) {
            /*Вычисляем параметр "t". Он будет принимать значения от 0 до 1. Например, если у нас 13 шагов
            интерполяции, то начальное "t" будет равно 1/13, а конечное "t" будет равно 12/13.*/
            const t = i / steps;
            /*Высчитываем X-координату текущей точки на основе параметра "t".*/
            const x = Math.round(x1 + dx * t);
            /*Высчитываем Y-координату текущей точки на основе параметра "t".*/
            const y = Math.round(y1 + dy * t);
            /*Добавляем высчитанную точку в массив точек.*/
            points.push({ x, y });
        };

        /*Здесь делаем проверку, чтобы избавиться от одинаковых точек в массиве.*/
        /*Во внешнем цикле "for" перебираем все точки в массиве "points".*/
        for (let i = 0; i < points.length; i++) {
            /*Во внутреннем цикле "for" перебираем только те точки в массиве "points", которые идут после точки взятой во внешнем цикле "for".*/
            for (let j = i + 1; j < points.length; j++) {
                /*Если координаты точки, взятой во внешнем цикле "for", равны координатом точки, взятой во внутреннем цикле, то удаляем
                точку, взятую во внутреннем цикле.*/
                if (points[i].x === points[j].x && points[i].y === points[j].y) {
                    points.splice(j, 1);
                    /*Поскольку массив уменьшился на один элемент, то итератор внутреннего цикла "for" уменьшаем на 1, чтобы не пропустить
                    элементы массива.*/
                    j--;
                };
            };
        };

        /*В конце своей работы функция возвращает массив точек.*/
        return points;
    }
};