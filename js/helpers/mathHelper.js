'use strict';
import { ctx, canvasData } from '../canvas/canvas.js';

export const mathHelper = {
    getRandomIntFromInterval: function (min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min);
    },

    /*Метод "preparePolygonIntVerticesData()" расчитывает координаты случайных вершин многоугольника в рамках указанной 
    области.
    
    Метод "preparePolygonIntVerticesData()" принимает следующие параметры:
    1. "numberOfVertices" - это числовой параметр, указывающий сколько вершин должно быть в многоугольнике.
    2. "x1" - это числовой параметр, указывающий левую X-координату области, в рамках которой должны быть вершины 
    многоугольника.
    3. "x2" - это числовой параметр, указывающий правую X-координату области, в рамках которой должны быть вершины 
    многоугольника.
    4. "y1" - это числовой параметр, указывающий верхнюю Y-координату области, в рамках которой должны быть вершины 
    многоугольника.
    5. "y2" - это числовой параметр, указывающий нижнюю Y-координату области, в рамках которой должны быть вершины 
    многоугольника.
    6. "clockwiseStepX" - это числовой параметр, указывающий максимальное расстояние сдвига по оси X вершин 
    многоугольника при движении по часовой стрелке по четвертям области, в рамках которой должны быть вершины 
    многоугольника.
    7. "clockwiseStepY" - это числовой параметр, указывающий максимальное расстояние сдвига по оси Y вершин 
    многоугольника при движении по часовой стрелке по четвертям области, в рамках которой должны быть вершины 
    многоугольника.
    8. "cellWidth" - это числовой параметр, указывающий ширину одной клетки в сетке холста.
    9. "cellHeight" - это числовой параметр, указывающий высоту одной клетки в сетке холста.
    10. "gridAligned" - это булев параметр, указывающий нужно ли выравнивать координаты вершин многоугольника по сетке.
    
    Логика работы метода "preparePolygonIntVerticesData()" следующая:
    1. Условно разбиваем на четыре четверти область, в рамках которой должны быть вершины многоугольник.
    2. Определяем сколько примерно вершин должно быть в каждой четверти области, в рамках которой должны быть вершины 
    многоугольника, исходя из общего количества вершин многоугольника.
    3. Рассчитываем первую координату многоугольника, которую распологаем примерно в верхней центральной части области, 
    в рамках которой должны быть вершины многоугольника.
    4. Рассчитываем координаты остальных вершин многоугольника при помощи движения по часовой стрелке по четвертям 
    области, в рамках которой должны быть вершины многоугольника.
    5. Выравниваем рассчитанные координаты вершин многоугольника по сетке.
    6. Корректируем рассчитанные координаты вершин многоугольника, которые выходят за пределы области, в рамках которой 
    должны быть вершины многоугольника.
    
    Нужно понимать, что качество работы этого метода во много зависит от адекватно подобранных параметров.
    
    Метод "preparePolygonIntVerticesData()" возвращает массив объектов с рассчитанными вершинами многоугольника.*/
    preparePolygonVerticesData: function (
        numberOfVertices,
        x1, x2,
        y1, y2,
        clockwiseStepX, clockwiseStepY,
        cellWidth, cellHeight,
        gridAligned
    ) {
        /*Создаем пустой массив "vertices", который нужен для заполнения его координатами вершин многоугольника.*/
        const vertices = [];

        /*Создаем переменные "currentX" и "currentY" для хранения X-координаты и Y-координаты рассчитываемой вершины 
        многоугольника соответственно.*/
        let currentX;
        let currentY;

        /*Рассчитываем сколько примерно вершин должно быть в каждой четверти области, в рамках которой должны быть 
        вершины многоугольника, и сохраняем результат в переменную "veticesPerQuarterMoving". Эта переменная нужна, 
        чтобы переходить от рассчета координат вершин многоугольника в одной четверти области, в рамках которой должны
        быть вершины многоугольника, в другую четверть этой области.*/
        const veticesPerQuarter = Math.ceil((numberOfVertices - 1) / 4);

        /*Создаем переменную "quarterStepCount", которая нужна для обозначения в какой четверти области, в рамках 
        которой должны быть вершины многоугольника, мы проводим рассчет координат вершин многоугольника.*/
        let quarterStepCount = 1;

        /*Расчитываем координаты вершин многоугольника.*/
        for (let i = 1; i <= numberOfVertices; i++) {
            /*Координаты первой вершины многоугольника рассчитываем отдельно. Располагаем первую вершину многоугольника 
            примерно в верхней центральной части области, в рамках которой должны быть вершины многоугольника.*/
            if (i === 1) {
                /*Рассчитываем X-координату первой вершины многоугольника:
                1. "(x2 - x1) / 2) + x1" - находим центральную X-координату области, в рамках которой должны быть 
                вершины многоугольника.
                2. "+ helper.randomIntFromInterval(-1 * cellWidth, cellWidth) + cellWidth * 3" - найденную X-координату 
                сдвигаем вправо случайно на 2-4 клетки, чтобы X-координата первой вершины многоугольника всегда 
                оказывалась в первой четверти области, в рамках которой должны быть вершины многоугольника.*/
                currentX = ((x2 - x1) / 2) + x1
                    + this.getRandomIntFromInterval(-1 * cellWidth, cellWidth) + cellWidth * 3;

                /*Рассчитываем Y-координату первой вершины многоугольника:
                1) "y1" - берем верхнюю Y-координату области, в рамках которой должны быть вершины многоугольника.
                2) "+ helper.randomIntFromInterval(Math.floor((y2 - y1) / 3), Math.floor((y2 - y1) / 2))" - взятую 
                Y-координату сдвигаем вниз случайно на расстояние из диапазона от 1/3 до 1/2 высоты области, в рамках 
                которой должны быть вершины многоугольника, чтобы первая вершина многоугольника всегда оказывалась в 
                указанной области.*/
                currentY = y1
                    + this.getRandomIntFromInterval(Math.floor((y2 - y1) / 3), Math.floor((y2 - y1) / 2));
            } else {
                /*Вершины многоугольника, кроме первой, рассчитываем при помощи движения по часовой стрелке по четвертям 
                области, в рамках которой должны быть вершины многоугольника.
                
                При расчете каждой вершини многоугольника определяем в какой четверти области, в рамках которой должны 
                быть вершины многоугольника, мы рассчитываем координаты вершин многоугольника:
                1 - Первая четверть.
                2 - Вторая четверть.
                3 - Третья четверть.
                4, 5 - Четвертая четверть.
                
                В каждой четверти области, в рамках которой должны быть вершины многоугольника, мы имитируем движение 
                координат вершин по часовой стрелке:
                1 - ↘ - Движение вправо и вниз.
                2 - ↙ - Движение влево и вниз.
                3 - ↖ - Движение влево и вверх.
                4, 5 - ↗ - Движение вправо и вверх.*/
                switch (quarterStepCount) {
                    /*Рассчитываем координаты вершин многоугольника в первой четверти области, в рамках которой должны 
                    быть вершины многоугольника.*/
                    case 1:
                        {
                            /*Берем X-координату предыдущей рассчитанной вершины многоугольника и случайно ее сдвигаем 
                            вправо минимум на 1 клетку, максимум до значения переменной "clockwiseStepX".*/
                            currentX = vertices[i - 2].x + this.getRandomIntFromInterval(cellWidth, clockwiseStepX);

                            /*Берем Y-координату предыдущей рассчитанной вершины многоугольника и случайно ее сдвигаем 
                            вниз минимум на 1 клетку, максимум до значения переменной "clockwiseStepY".*/
                            currentY = vertices[i - 2].y + this.getRandomIntFromInterval(cellHeight, clockwiseStepY);
                            break;
                        };

                    /*Рассчитываем координаты вершин многоугольника во второй четверти области, в рамках которой должны 
                    быть вершины многоугольника.*/
                    case 2:
                        {
                            /*Берем X-координату предыдущей рассчитанной вершины многоугольника и случайно ее сдвигаем 
                            влево минимум на 1 клетку, максимум до значения переменной "clockwiseStepX".*/
                            currentX = vertices[i - 2].x - this.getRandomIntFromInterval(cellWidth, clockwiseStepX);

                            /*Берем Y-координату предыдущей рассчитанной вершины многоугольника и случайно ее сдвигаем 
                            вниз минимум на 1 клетку, максимум до значения переменной "clockwiseStepY".*/
                            currentY = vertices[i - 2].y + this.getRandomIntFromInterval(cellHeight, clockwiseStepY);
                            break;
                        };

                    /*Рассчитываем координаты вершин многоугольника в третьей четверти области, в рамках которой должны 
                    быть вершины многоугольника.*/
                    case 3:
                        {
                            /*Берем X-координату предыдущей рассчитанной вершины многоугольника и случайно ее сдвигаем 
                            влево минимум на 1 клетку, максимум до значения переменной "clockwiseStepX".*/
                            currentX = vertices[i - 2].x - this.getRandomIntFromInterval(cellWidth, clockwiseStepX);

                            /*Берем Y-координату предыдущей рассчитанной вершины многоугольника и случайно ее сдвигаем 
                            вверх минимум на 1 клетку, максимум до значения переменной "clockwiseStepY".*/
                            currentY = vertices[i - 2].y - this.getRandomIntFromInterval(cellHeight, clockwiseStepY);
                            break;
                        };

                    /*Рассчитываем координаты вершин многоугольника в четвертой четверти области, в рамках которой 
                    должны быть вершины многоугольника. Если мы имеем нечетное количество вершин, то под конец расчета 
                    координат вершин многоугольника мы можем перейти в несуществующую пятую четверть области, в рамках 
                    которой должны быть вершины многоугольника. Чтобы это не вызывало проблем рассчитываем координаты 
                    вершин многоугольника в этой пятой четверти таким же способом, как и в четвертой четверти.*/
                    case 4:
                    case 5:
                        {
                            /*Берем X-координату предыдущей рассчитанной вершины многоугольника и случайно ее сдвигаем 
                            вправо минимум на 1 клетку, максимум до значения переменной "clockwiseStepX".*/
                            currentX = vertices[i - 2].x + this.getRandomIntFromInterval(cellWidth, clockwiseStepX);

                            /*Проверяем не получилось ли так, что рассчитанная X-координата вершины многоугольника 
                            больше или равна X-координате первой вершины многоугольника. Если это так, то сдвигаем 
                            вправо на 1 клетку рассчитанную X-координату вершины многоугольника и X-координату 
                            предыдущей расчитанной вершины многоугольника. Эта проверка нужна, чтобы не было склеек 
                            вершин и сгибаний многоугольника вокруг одной вершины.*/
                            while (currentX >= vertices[0].x) {
                                vertices[i - 2].x = vertices[i - 2].x - cellWidth;
                                currentX = currentX - cellWidth;
                            };

                            /*Берем Y-координату предыдущей вершины и случайно ее сдвигаем вверх минимум на 1 клетку, 
                            максимум до значения переменной "quarterMovingStepSizeY".*/
                            currentY = vertices[i - 2].y - this.getRandomIntFromInterval(cellHeight, clockwiseStepY);
                            break;
                        };

                    default:
                        break;
                };
            };

            /*Если указано, что нужно выравнить координаты вершин многоугольника по сетке, то делаем это.*/
            if (gridAligned) {
                /*Выравниваем рассчитанную X-координату вершины многоугольника по сетке. Делим рассчитанную X-координату 
                вершины многоугольника на ширину клетки и находим остаток.*/
                if (currentX % cellWidth >= cellWidth / 2) {
                    /*Если остаток больше или равен половине ширины клетки, то округляем рассчитанную X-координату 
                    вершины многоугольника по верху (например, 382 -> 400):
                    1. "Math.trunc(currentX / cellWidth)" - находим целую часть от деления (например, 382 / 50 = 7).
                    2. "+ 1" - прибавляем к целой части от деления 1, чтобы потом полученную целую часть умножить на 
                    ширину клетки (например, 7 + 1 = 8).
                    3. "* cellWidth" - полученную целую часть умножаем на ширину клетки (например, 8 * 50 = 400).*/
                    currentX = (Math.trunc(currentX / cellWidth) + 1) * cellWidth;
                } else {
                    /*Если остаток меньше половины ширины клетки, то округляем рассчитанную X-координату вершины 
                    многоугольника по низу (например, 354 -> 350):
                    1. "Math.trunc(currentX / cellWidth)" - находим целую часть от деления (например, 354 / 50 = 7).
                    2. "* cellWidth" - полученную целую часть умножаем на ширину клетки (например, 7 * 50 = 350).*/
                    currentX = Math.trunc(currentX / cellWidth) * cellWidth;
                };

                /*Выравниваем рассчитанную Y-координату вершины многоугольника по сетке аналогичным способом.*/
                if (currentY % cellHeight >= cellHeight) {
                    currentY = (Math.trunc(currentY / cellHeight) + 1) * cellHeight;
                } else {
                    currentY = Math.trunc(currentY / cellHeight) * cellHeight;
                };
            };

            /*Корректируем рассчитанную X-координату вершины многоугольника если она выходит за пределы области, в 
            рамках которой должны быть вершины многоугольника.
    
            Если рассчитанная X-координата вершины многоугольника правее правой X-координаты области, в рамках которой 
            должны быть вершины многоугольника, то делаем так, чтобы рассчитанная X-координата вершины многоугольника 
            была равна правой X-координате упомянутой области.*/
            if (currentX >= x2) { currentX = x2 };
            /*Если рассчитанная X-координата вершины многоугольника левее левой X-координаты области, в рамках которой 
            должны быть вершины многоугольника, то делаем так, чтобы рассчитанная X-координата вершины многоугольника 
            была равна левой X-координате упомянутой области.*/
            if (currentX <= x1) { currentX = x1 };

            /*Корректируем рассчитанную Y-координату вершины многоугольника если она выходит за пределы области, в 
            рамках которой должны быть вершины многоугольника, аналогичным способом.*/
            if (currentY >= y2) { currentY = y2 };
            if (currentY <= y1) { currentY = y1 };

            /*Корректируем рассчитанную X-координату предыдущей рассчитанной вершины многоугольника если она выходит за 
            пределы области, в рамках которой должны быть вершины многоугольника, аналогичным способом. 
            
            Эта проверка нужна если при расчете X-координат в четвертой четверти области, в рамках которой должны быть 
            вершины многоугольника, нам пришлось изменить уже рассчитанную X-координату предыдущей рассчитанной вершины 
            многоугольника и изменненая X-координата вышла за предела упомянутой области.*/
            if (vertices[i - 2]) {
                if (vertices[i - 2].x >= x2) { vertices[i - 2].x = x2 };
                if (vertices[i - 2].x <= x1) { vertices[i - 2].x = x1 };
            };

            /*Рассчитав и откорректировав координаты вершины многоугольника добавляем их в массив "vertices".*/
            vertices.push({ x: currentX, y: currentY });

            /*Проверяем не нужно ли для расчета координат следующей вершины многоугольника перейти в следущую четверть 
            области, в рамках которой должны быть вершины многоугольника. 
    
            Мы делаем такой переход только если количество уже рассчитанных вершин многоугольника кратно примерному 
            количеству вершин в каждой четверти упомянутой области из переменной "veticesPerQuarter". Такая логика 
            позволяет рассчитывать примерно одинаковое количество вершин многоугольника в каждой четверти области, в 
            рамках которой должны быть вершины многоугольника.*/
            if (i % veticesPerQuarter === 0) { quarterStepCount++ };
        };

        /*Отрисовываем область, в рамках которой должны быть вершины многоугольника. Это нужно только для 
        тестирования.*/
        // ctx.lineWidth = 3;
        // ctx.strokeStyle = 'red';
        // ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);

        /*Проверяем не получилось ли у нас вершин с одинаковыми координатами. Это нужно только для тестирования.*/
        // for (let i = 0; i < vertices.length; i++) {
        //     for (let j = i + 1; j < vertices.length; j++) {
        //         if (vertices[i].x === vertices[j].x && vertices[i].y === vertices[j].y) {
        //             console.log(`WARNING Duplicate Vertices ${i} and ${j}`);
        //         };
        //     };
        // };

        /*Выводим информацию о вершинах многоугольника в консоль. Это нужно только для тестирования.*/
        // console.log(`Vertices' Coordinates:`);
        // console.log(vertices);
        // console.log('--------------------------------------');

        /*Возвращаем массив объектов с рассчитанными координатами вершин многоугольника.*/
        return vertices;
    },

    /*Метод "findIntPointOnLineSegment()" находит точки с целочисленными координатами на отрезке, используя линейную 
    интерполяцию. Линейная интерполяция - это метод нахождения промежуточных значений между двумя известными точками на 
    прямой линии.

    Метод "findIntPointOnLineSegment()" принимает следующие параметры:
    1. "x1" - это числовой параметр, указывающий X-координату первой точки отрезка.
    2. "y1" - это числовой параметр, указывающий Y-координату первой точки отрезка.
    3. "x2" - это числовой параметр, указывающий X-координату второй точки отрезка.
    4. "y2" - это числовой параметр, указывающий Y-координату второй точки отрезка.

    Логика работы метода "findIntPointOnLineSegment()" следующая:
    1. Находим длину отрезка между двумя указанными точками.
    2. Находим количество шагов интерполяции, то есть количество точек на отрезке.
    3. Проходим по шагам интерполяции и вычисляем целочисленные координаты точек на отрезке.
    4. Избавляемся от дупликатов точек, если таковые имеются.

    Метод "findIntPointOnLineSegment()" возвращает массив с целочисленными координатами найденных точек на отрезке.*/
    findIntPointsOnLineSegment: function (x1, y1, x2, y2) {
        /*Создаем пусстой массив "points", который нужен для заполнения его целочисленными координатами найденных точек
        на отрезке.*/
        const points = [];

        /*Находим разность X-координат конечных точек отрезка.*/
        const dx = x2 - x1;
        /*Находим разность Y-координат конечных точек отрезка.*/
        const dy = y2 - y1;
        /*Находим расстояние между конечными точками отрезка по формуле расстояния между точками, которая работает на 
        основе теоремы Пифагора.*/
        const distance = Math.sqrt(dx * dx + dy * dy);

        /*Находим количество шагов интерполяции, то есть количество точек на отрезке, путем округления длины отрезка 
        понизу.*/
        const steps = Math.floor(distance);

        /*Проходим по шагам интерполяции и вычисляем целочисленные координаты точек на отрезке.*/
        for (let i = 0; i <= steps; i++) {
            /*Вычисляем параметр "progress", который принимает значения от 0 до 1. Параметр "progress" - это параметр 
            параметризации, описывающий положение точки на отрезке. Например, если у нас 13 шагов интерполяции, то 
            параметр "progress" будет принимать значения от 0/13 до 13/13.*/
            const progress = i / steps;

            /*Высчитываем целочисленную X-координату текущей точки на отрезке.*/
            const x = Math.round(x1 + dx * progress);
            /*Высчитываем целочисленную Y-координату текущей точки на отрезке.*/
            const y = Math.round(y1 + dy * progress);

            /*Добавляем высчитанные целочисленные координаты текущей точки в массив "points".*/
            points.push({ x, y });
        };

        /*Избавляемся от дупликатов точек, если таковые имеются. Во внешнем цикле for перебираем все точки в массиве 
        "points".*/
        for (let i = 0; i < points.length; i++) {
            /*Во внутреннем цикле for перебираем только те точки в массиве "points", которые идут после точки взятой 
            во внешнем цикле for.*/
            for (let j = i + 1; j < points.length; j++) {
                /*Если координаты точки, взятой во внешнем цикле for, равны координатам точки, взятой во внутреннем 
                цикле for, то удаляем точку, взятую во внутреннем цикле for. Поскольку в этом случае массив "points" 
                уменьшается на один элемент, то переменную-итератор "j" внутреннего цикла for уменьшаем на 1, чтобы не 
                пропустить какие-то элементы массива "points" при их дальнейшем переборе.*/
                if (points[i].x === points[j].x && points[i].y === points[j].y) {
                    points.splice(j, 1);
                    j--;
                };
            };
        };

        /*Выводим информацию о точках на отрезке в консоль. Это нужно только для тестирования.*/
        // console.log(`${points.length} points on the line segment:`);
        // console.log(points);
        // console.log('--------------------------------------');

        /*Возвращаем массив с целочисленными координатами найденных точек на отрезке.*/
        return points;
    },

    /*Метод "findIntPointsOnPolygonEdges()" находит точки с целочисленными координатами на всех сторонах 
    многоугольника.
    
    Метод "findIntPointsOnPolygonEdges()" принимает следующие параметры:
    "vertices" - это параметр в виде массива объектов, содержащих целочисленные координаты вершин многоугольника.

    Логика работы метода "findIntPointsOnPolygonEdges()" следующая:
    1. Перебираем все соседние пары вершины многоугольника.
    2. Находим точки с целочисленными координатами на каждой стороне многоугольника при помощи метода 
    "helper.findIntPointOnLineSegment()".
    3. Избавляемся от дупликатов точек, если таковые имеются.

    Метод "findIntPointsOnPolygonEdges()" возвращает массив целочисленных координат точек на каждой стороне 
    многоугольника.*/
    findIntPointsOnPolygonEdges: function (vertices) {
        /*Создаем пусстой массив "points", который нужен для заполнения его целочисленными координатами найденных точек
        на сторонах многоугольника.*/
        const points = [];

        /*Перебираем все соседние пары вершины многоугольника (например, если у нас 12 вершин многоугольника, то 
        перебираем его вершины в таком порядке: 1 и 2 -> 2 и 3 -> 3 и 4 -> ... -> 13 и 1), чтобы при помощи метода 
        "helper.findIntPointOnLineSegment()" найти точки с целочисленными координатами на каждой стороне 
        многоугольника.*/
        for (let i = 0; i < vertices.length; i++) {
            /*Каждый цикл переменная "i" представлет номер первой вершины многоугольника в паре, а переменная "k" номер 
            второй вершины многоугольника в паре.*/
            let k;

            /*Если текущая вершина "i" многоугольника не является последней вершиной многоугольника в массиве 
            "vertices", то номер второй вершины "k" многоугольника равен номеру текущей вершины "i" многоугольника, 
            увеличенному на 1, что означает соседнюю вершину многоугольника для вершины "i" многоугольника.
            
            Если же текущая вершина "i" многоугольника является последней вершиной многоугольника в массиве "vertices",
            то для того, чтобы найти целочисленные координаты точек между последней и первой вершинами многоугольника, 
            номер второй вершины "k" многоугольника равен 0, что означает первую вершину многоугольника из массива 
            "vertices".*/
            if (i !== vertices.length - 1) { k = i + 1 } else { k = 0 };

            /*При помощи метода "helper.findIntPointOnLineSegment()" находим массив точек с целочисленными координатами
            на стороне многоугольника и добавляем эти точки в массив "points".*/
            points.push(
                ...this.findIntPointsOnLineSegment(vertices[i].x, vertices[i].y, vertices[k].x, vertices[k].y)
            );
        };

        /*Избавляемся от дупликатов точек, если таковые имеются. Во внешнем цикле for перебираем все точки в массиве 
        "points".*/
        for (let i = 0; i < points.length; i++) {
            /*Во внутреннем цикле for перебираем только те точки в массиве "points", которые идут после точки взятой 
            во внешнем цикле for.*/
            for (let j = i + 1; j < points.length; j++) {
                /*Если координаты точки, взятой во внешнем цикле for, равны координатам точки, взятой во внутреннем 
                цикле for, то удаляем точку, взятую во внутреннем цикле for. Поскольку в этом случае массив "points" 
                уменьшается на один элемент, то переменную-итератор "j" внутреннего цикла for уменьшаем на 1, чтобы не 
                пропустить какие-то элементы массива "points" при их дальнейшем переборе.*/
                if (points[i].x === points[j].x && points[i].y === points[j].y) {
                    points.splice(j, 1);
                    j--;
                };
            };
        };

        /*Отрисовываем найденные точки. Это нужно только для тестирования.*/
        // for (let i = 0; i < points.length; i++) {
        //     ctx.fillStyle = helper.getRandomColor();
        //     ctx.fillRect(points[i].x, points[i].y, 5, 5);
        // };

        /*Выводим информацию о точках на каждой стороне многоугольника в консоль. Это нужно только для тестирования.*/
        // console.log(`${points.length} points on the polygon's edges:`);
        // console.log(points);
        // console.log('--------------------------------------');

        /*Возвращаем массив с целочисленными координатами найденных точек на каждой стороне многоугольника.*/
        return points;
    },

    /*Метод "isPointInsidePolygon()" определяет находится ли точка внутри многоугольника, используя метод луча.

    Метод луча примерно работает следующим образом:
    1. Из указанной точки пускаем луч в правую или левую сторону (в нашем случае - в правую). 
    2. Подсчитываем количество пересечений луча со сторонами многоугольника.
    3. Если подсчитанное количество пересечений нечетное, то это означает, что точка находится внутри многоугольника, 
    иначе точка находится снаружи многоугольника.*

    Метод "isPointInsidePolygon()" принимает следующие параметры:
    1. "point" - это параметр в виде объекта, содержащий целочисленные координаты точки для определения находится ли 
    она внутри многоугольника.
    2. "vertices" - это параметр в виде массива объектов, содержащих целочисленные координаты вершин многоугольника.

    Логика работы метода "isPointInsidePolygon()" следующая:
    1. Находим точку пересечения луча и правой (так как пускаем луч вправо) стороны холста.
    2. Находи точки с целочисленными координатами на отрезке луча, ограниченного холстом, при помощи метода 
    "helper.findIntPointsOnLineSegment()".
    3. Находим массив с целочисленными координатами точек на каждой стороне многоугольника при помощи метода
    "helper.findIntPointsOnPolygonEdges()".

    Метод "isPointInsidePolygon()" возвращает true, если точка находится внутри многоугольника, иначе возвращает 
    false.*/
    isPointInsidePolygon: function (point, vertices) {
        /*Создаем переменные "minX", "maxX", "minY" и "maxY" для хранения минимальной X-координаты, максимальной
        X-координаты, минимальной Y-координаты и максимальной Y-координаты соответственно среди всех вершин 
        многоугольника.*/
        let minX = vertices[0].x;
        let maxX = vertices[0].x;
        let minY = vertices[0].y;
        let maxY = vertices[0].y;

        /*Находим минимальную X-координату, максимальную X-координату, минимальную Y-координату и максимальную 
        Y-координату среди всех вершин многоугольника.*/
        for (let i = 0; i < vertices.length; i++) {
            if (vertices[i].x < minX) { minX = vertices[i].x };
            if (vertices[i].x > maxX) { maxX = vertices[i].x };
            if (vertices[i].y < minY) { minY = vertices[i].y };
            if (vertices[i].y > maxY) { maxY = vertices[i].y };
        };

        

        /*Указанная точка всегда находится снаружи многоугольника, если выполняется одно из следующих условий:
        1. Точка левее минимальной X-координаты многоугольника и выше минимальной Y-координаты многоугольника. 
        2. Точка правее максимальной X-координаты многоугольника и выше минимальной Y-координаты многоугольника.
        3. Точка правее максимальной X-координаты многоугольника и ниже максимальной Y-координаты многоугольника.
        4. Точка левее минимальной X-координаты многоугольника и ниже максимальной Y-координаты многоугольника.

                                        (0,0)        minX    maxX      X
                                            .-------------------------->
                                            |         :        :
                                            |   1.->  :        :   <-.2
                                            |    ↓    :        :     ↓
                                        minY|......... ________.........
                                            |         /        \
                                        maxY|.........\________/........
                                            |         :        :
                                            |    ↑    :        :     ↑
                                            |   4*->  :        :   <-*3
                                            |         :        :
                                            ↓Y
        */
        if (
            (point.x <= minX & point.y <= minY) ||
            (point.x >= maxX & point.y <= minY) ||
            (point.x >= maxX & point.y >= maxY) ||
            (point.x <= minX & point.y >= maxY)
        ) {
            /*Если выполняется одно из указанный условий, то это означает, что не смысла проводить дальнейшую проверку,
            поэтому возвращаем false, как знак, что точка находится вне многоугольника.*/
            return false;
        };

        /*Поскольку наш холст имеет ограниченые размеры, то нам не нужен весь луч, а только лишь его отрезок, 
        ограниченный холстом. Поэтому формируем данные для точки пересечения луча и правой (так как пускаем луч вправо) 
        границы холста, и сохраняем эти данные в переменной "rayIntersectionPoint".*/
        const rayCanvasIntersectionPoint = { x: canvasData.canvasWidth, y: point.y };

        /*Находим целочисленные координаты точек на отрезке луча при помощи метода "helper.findIntPointsOnLineSegment()"
        и сохраняем их в переменной "rayPoints".*/
        const rayPoints = this.findIntPointsOnLineSegment(point.x, point.y,
            rayCanvasIntersectionPoint.x, rayCanvasIntersectionPoint.y);

        /*Находим массив с целочисленными координатами точек на каждой стороне многоугольника при помощи метода 
        "helper.findIntPointsOnPolygonEdges()" и сохраняем его в переменную "pointsOnPolygonEdges".*/
        const pointsOnPolygonEdges = this.findIntPointsOnPolygonEdges(vertices);

        /*Создаем переменную "intersections" для подсчета пересечений луча со сторонами многоугольника.*/
        let intersections = 0;

        /*Создаем пусстой массив "intersectionPoints", который нужен для заполнения его целочисленными координатами 
        точек пересечений луча и сторон многоугольника.*/
        const intersectionPoints = [];

        /*Внешним циклом for перебираем точки на отрезке луче.*/
        for (let i = 0; i < rayPoints.length; i++) {
            /*Внутренним циклом for перебираем точки на сторонах многоугольника.*/
            for (let j = 0; j < pointsOnPolygonEdges.length; j++) {
                /*Если взятая точка на отрезке луча совпадает с взятой точкой на стороне многоугольника, то добоавляем
                эту точку в массив "intersectionPoints".*/
                if (rayPoints[i].x === pointsOnPolygonEdges[j].x && rayPoints[i].y === pointsOnPolygonEdges[j].y) {
                    // console.log(`Intersection registered: Ray point (${rayPoints[i].x}, ${rayPoints[i].y}) and Point on an edge of the polygon (${pointsOnPolygonEdges[j].x}, ${pointsOnPolygonEdges[j].y})`);
                    // console.log('--------------------------------------');

                    /*Отрисовываем желтым цветом взятую точку на отрезке луча. Это нужно только для тестирования.*/
                    // ctx.fillStyle = 'yellow';
                    // ctx.fillRect(rayPoints[i].x, rayPoints[i].y, 10, 10);

                    /*Отрисовываем зеленым цветом взятую точку на стороне многоугольника. Это нужно только для 
                    тестирования.*/
                    // ctx.fillStyle = 'green';
                    // ctx.fillRect(pointsOnPolygonEdges[j].x, pointsOnPolygonEdges[j].y, 5, 5);

                    intersectionPoints.push(pointsOnPolygonEdges[j]);
                };
            };
        };

        /*Пробегаемся по массиву "intersectionPoints" с конца в начало, чтобы регистрировать пересечения точек луча и 
        точек на сторонах многоугольника. Это мы делаем в каждом случае, кроме случаев когда у соседних точек, которые 
        находятся на одной и той же Y-координате, их X-координаты отличаются на 1. Эта проверка нужна, чтобы избежать 
        случаев, когда какая-то сторона многоугольника совпадает с лучом. Эта проверка игнорирует первую точку в 
        массиве "intersectionPoints", так как для нее нет пары в виде предыдущей точки.*/
        for (let i = intersectionPoints.length - 1; i > 0; i--) {
            if (
                !(intersectionPoints[i].y === intersectionPoints[i - 1].y &&
                    intersectionPoints[i].x === intersectionPoints[i - 1].x + 1)
            ) {
                intersections++;
            };
        };

        /*Поскольку в предыдущей проверке мы игнорируем первую точку в массиве "intersectionPoints", отдельно 
        засчитываем для нее одно пересечение.*/
        if (intersectionPoints.length > 0) { intersections++ };

        /*Отрисовываем луч из указанной точки в правую сторону. Это нужно только для тестирования.*/
        // ctx.fillStyle = 'purple';
        // ctx.fillRect(point.x, point.y, canvasData.canvasWidth, 10);

        /*Выводим информацию о точках на отрезке луча в консоль. Это нужно только для тестирования.*/
        // console.log(`${rayPoints.length} points on the ray:`);
        // console.log(rayPoints);
        // console.log('--------------------------------------');

        /*Выводим информацию о количестве пересечений отрезка луча и сторон многоугольника. Это нужно только для 
        тестирования.*/
        // console.log(`Intersections between the ray and the polygon's edges: ${intersections}`);
        // console.log('--------------------------------------');

        /*Если количество пересечений нечетное, что означает точка находится внутри многоугольника, то возвращаем true. 
        Если количество пересечений четное, что означает точка находится снаружи многоугольника, то возвращаем false.*/
        if (intersections % 2 !== 0) {
            /*Отрисовываем зеленый квадрат, как знак, что точка находится внутри многоугольника. Это нужно только для 
            тестирования.*/
            // ctx.fillStyle = 'green';
            // ctx.fillRect(700, 50, 50, 50);

            /*Выводим в консоль true как знак, что точка находится внутри многоугольника. Это нужно только для 
            тестирования.*/
            // console.log(true);
            // console.log('--------------------------------------');

            /*Метод возвращает true, как знак, что точка находится внутри многоугольника.*/
            return true;
        } else {
            /*Отрисовываем красный квадрат, как знак, что точка находится снаружи многоугольника. Это нужно только для 
            тестирования.*/
            // ctx.fillStyle = 'red';
            // ctx.fillRect(700, 50, 50, 50); 

            /*Выводим в консоль false, как знак, что точка находится снаружи многоугольника. Это нужно только для 
            тестирования.*/
            // console.log(false);
            // console.log('--------------------------------------');

            /*Метод возвращает false, как знак, что точка находится вне многоугольника.*/
            return false;
        };
    },

    /*Метод "getCrossProduct()" рассчитывает векторное произведение двух векторов.
    
    В двумерном пространстве векторное произведение двух векторов не определено в классическом понимании, так как 
    векторное произведение существует только в трехмерном пространстве. Однако в двумерном случае можно рассмотреть 
    псевдоскалярное произведение, которое возвращает число, а не вектор. Это число соответствует третьей компоненте 
    векторного произведения, если бы векторы были дополнены до трехмерных. Векторное произведение двух векторов в 
    двумерном пространстве - это число, которое показывает, как эти векторы ориентированы относительно друг друга.
    
    Для двух векторов AB = (Bx - Ax, By - Ay) и CD = (Dx - Cx, Dy - Cy) векторное произведение вычисляется по формуле:
    AB * CD = (Bx - Ax) * (Dy - Cy) - (By - Ay) * (Dx - Cx).
    
    Метод "getCrossProduct()" принимает следующие параметры:
    1. "v1StartPointX" - это числовой параметр, содержащий X-координату начальной точки первого вектора.
    2. "v1StartPointY" - это числовой параметр, содержащий Y-координату начальной точки первого вектора.
    3. "v1EndPointX" - это числовой параметр, содержащий X-координату конечной точки первого вектора.
    4. "v1EndPointY" - это числовой параметр, содержащий Y-координату конечной точки первого вектора.
    5. "v2StartPointX" - это числовой параметр, содержащий X-координату начальной точки второго вектора.
    6. "v2StartPointY" - это числовой параметр, содержащий Y-координату начальной точки второго вектора.
    7. "v2EndPointX" - это числовой параметр, содержащий X-координату конечной точки второго вектора.
    8. "v2EndPointY" - это числовой параметр, содержащий Y-координату конечной точки второго вектора.
    
    Метод "getCrossProduct()" возвращает величину векторного произведения двух векторов.*/
    getCrossProduct: function (
        v1StartPointX, v1StartPointY, v1EndPointX, v1EndPointY,
        v2StartPointX, v2StartPointY, v2EndPointX, v2EndPointY
    ) {
        return (v1EndPointX - v1StartPointX) * (v2EndPointY - v2StartPointY) -
            (v1EndPointY - v1StartPointY) * (v2EndPointX - v2StartPointX);
    },

    /*Метод "getPointPositionRelativeToLineSegment()" определяет положение точки относительно прямой, содержащей 
    отрезок, заданный двумя точками, используя геометрический смысл векторного произведения векторов. 
    
    Геометрический смысл векторного произведения векторов на примере точки P и прямой, содержащей отрезок AB:
    1. Если векторное произведение двух векторов AB и AP положительное, то это означает, что:
        1) Точка P находится слева от прямой, содержащей отрезок AB.
        2) Вектор AP "повернут" относительно вектора AB против часовой стрелки.

    2. Если векторное произведение двух векторов AB и AP отрицательное, то это означает, что:
        1) Точка P находится справа от прямой, содержащей отрезок AB.
        2) Вектор AP "повернут" относительно вектора AB по часовой стрелке.

    3. Если векторное произведение двух векторов AB и AP равно нулю, то это означает, что:
        1) Точка P лежит на прямой, содержащей отрезок AB.
        2) Векторы AB и AP коллинеарны, то есть лежат на одной прямой.

    Метод "getPointPositionRelativeToLineSegment()" принимает следующие параметры:
    1. "v1StartPointX" - это числовой параметр, содержащий X-координату начальной точки вектора.
    2. "v1StartPointY" - это числовой параметр, содержащий Y-координату начальной точки вектора.
    3. "v1EndPointX" - это числовой параметр, содержащий X-координату конечной точки вектора.
    4. "v1EndPointY" - это числовой параметр, содержащий Y-координату конечной точки вектора.
    5. "pointX" - это числовой параметр, содержащий X-координату точки.
    6. "pointY" - это числовой параметр, содержащий Y-координату точки.

    Метод "getPointPositionRelativeToLineSegment()" возвращает .*/
    getPointPositionRelativeToLineSegment: function (
        v1StartPointX, v1StartPointY,
        v1EndPointX, v1EndPointY,
        pointX, pointY
    ) {
        const crossProduct = this.getCrossProduct(
            v1StartPointX, v1StartPointY, v1EndPointX, v1EndPointY,
            v1StartPointX, v1StartPointY, pointX, pointY
        );

        /*Создаем переменную "epsilon", которая имитирует символ ε (эпсилон), используемый для обозначения 
        положительного сколь угодно малого вещественного числа. При помощи него мы устанавливаем порог для учета 
        погрешности вычислений.
        
        1e-12 это научная запись числа 1×10^(−12), то есть 0.000 000 000 001 (одна триллионная). Это очень маленькое 
        число, которое используется как порог для учета погрешности вычислений.

        Почему используется 1e-12:
        1. Проблема точности вычислений. В компьютерах числа с плавающей запятой имеют ограниченную точность. Из-за 
        этого результат вычислений может быть не точным, а лишь приближенным. Например, вместо нуля может получиться 
        очень маленькое число, например, 1e-15.

        2. Порог погрешности. Чтобы учесть эту погрешность, вместо строгого сравнения с нулем используется сравнение с 
        очень маленьким числом, например, 1e-12. Если величина векторного произведения двух векторов меньше 1e-12, то 
        она считается "практически нулевой", и точка считается лежащей на прямой, содержащей отрезок.    

        Переменная "epsilon" нужна для определения коллинеарности. Если векторное произведение двух векторов равно нулю, 
        то это означает, что эти векторы коллинеарны. Однако из-за погрешности вычислений результат может быть не точно 
        нулевым, а очень близким к нулю. Поэтому мы используем порог 1e-12, чтобы учесть эту погрешность.

        Например, предположим, что векторное произведение двух векторов равно 1e-14. Это очень близкое к нулю значение, 
        которое меньше, чем 1e-12. С практической точки зрения можно считать, что точка лежит на прямой. Но если бы мы 
        использовали строгое сравнение с нулем, то результат был бы false, что было бы неправильно.*/
        const epsilon = 1e-12;

        /*Если векторное произведение двух векторов, учитывая погрешность, равно нулю, то это означает, что точка 
        находится на прямой, содержащей отрезок. В этом случае вовзращаем 0, как знак того, что точка находится на 
        прямой, содержащей отрезок.*/
        if (Math.abs(crossProduct) < epsilon) return 0;

        /*Если векторное произведение двух векторов, учитывая погрешность, больше чем ноль, то это означает, что точка 
        находится слева от прямой, содержащей отрезок. В этом случае вовзращаем 1, как знак того, что точка находится 
        слева от прямой, содержащей отрезок.*/
        if (crossProduct > 0) return 1;

        /*Если векторное произведение, учитывая погрешность, меньше чем ноль, то это означает, что точка находится 
        справа от прямой, содержащей отрезок. В этом случае вовзращаем -1, как знак того, что точка находится справа от 
        прямой, содержащей отрезок.*/
        return -1;
    }
};


/*Функция для нахождения скалярного произведения векторов.

Скалярное произведение двух векторов - это число, которое показывает, насколько один вектор "проецируется" на другой.

Для двух векторов AB = (Bx - Ax, By - Ay) и CD = (Dx - Cx, Dy - Cy) скалярноt произведение вычисляется по формуле:

AB x CD = (Bx - Ax) * (Dx - Cx) + (By - Ay) * (Dy - Cy).*/
function getDotProduct(
    v1StartPointX, v1StartPointY, v1EndPointX, v1EndPointY,
    v2StartPointX, v2StartPointY, v2EndPointX, v2EndPointY
) {
    return (v1EndPointX - v1StartPointX) * (v2EndPointX - v2StartPointX) +
        (v1EndPointY - v1StartPointY) * (v2EndPointY - v2StartPointY);
};

/*Функция для определения направления двух векторов относительно друг друга.

Геометрический смысл скалярного произведения векторов:
Если скалярное произведение положительное, векторы направлены в одну сторону.
Если скалярное произведение отрицательное, векторы направлены в противоположные стороны.
Если скалярное произведение равно нулю, векторы перпендикулярны.*/
function checkVectorsRelativeDirection(
    v1StartPointX, v1StartPointY, v1EndPointX, v1EndPointY,
    v2StartPointX, v2StartPointY, v2EndPointX, v2EndPointY
) {
    const dotProduct = getDotProduct(
        v1StartPointX, v1StartPointY, v1EndPointX, v1EndPointY,
        v2StartPointX, v2StartPointY, v2EndPointX, v2EndPointY
    );

    // Порог для учета погрешности вычислений
    const epsilon = 1e-12;

    if (Math.abs(dotProduct) < epsilon) return 0; // векторы перпендикулярны.
    if (dotProduct > 0) return 1; // векторы направлены в одну сторону.
    return -1; // векторы направлены в противоположные стороны.
};

function getSquaredVectorLength(v1StartPointX, v1StartPointY, v1EndPointX, v1EndPointY) {
    return (v1EndPointX - v1StartPointX) * (v1EndPointX - v1StartPointX) +
        (v1EndPointY - v1StartPointY) * (v1EndPointY - v1StartPointY);
};

function isPointOnLineSegment(v1StartPointX, v1StartPointY, v1EndPointX, v1EndPointY, pointX, pointY) {
    /*ШАГ 1*/
    // Используем getPointPositionRelativeToLine для проверки, лежит ли точка на прямой
    const pointPositionRelativeToLineSegment = getPointPositionRelativeToLineSegment(
        v1StartPointX, v1StartPointY, v1EndPointX, v1EndPointY,
        pointX, pointY
    );

    if (pointPositionRelativeToLineSegment !== 0) return false; // Точка не лежит на прямой

    /*ШАГ 2*/
    /*Используем getDotProduct для проверки, лежит ли точка внутри bounding box отрезка.*/
    const dotProduct = getDotProduct(
        v1StartPointX, v1StartPointY, v1EndPointX, v1EndPointY,
        v1StartPointX, v1StartPointY, pointX, pointY
    );

    /*ШАГ 2.1*/
    // Если dotProduct < 0, точка лежит до начальной точки A (за пределами отрезка) так как получается что точка P лежит до точки A (за пределами отрезка).
    if (dotProduct < 0) return false;

    /*ШАГ 2.2*/
    /*Если два вектора выходят из одной точки и их скалярное произведение больше, чем квадрат длины левого вектора, то 
    это означает, что конечная точка правого вектора дальше конечной точки левого вектора.
    
    Для вектора AB квадрат его длины вычисляет следующим образом: (Bx - Ax)^2 + (By - Ay)^2*/
    // Квадрат длины отрезка
    const squaredLength = getSquaredVectorLength(v1StartPointX, v1StartPointY, v1EndPointX, v1EndPointY);

    if (dotProduct > squaredLength) return false; // Точка за пределами отрезка (ближе к конечной точке) так как получается что точка P лежит после точки B (за пределами отрезка).

    // Если все проверки пройдены, точка лежит на отрезке
    return true;
};

// Функция для проверки пересечения двух отрезков
function doLineSegmentsIntersect(p1, p2, p3, p4) {
    /*Проверяем, где находится точка p3 относительно отрезка p1-p2.*/
    const orientation1 = getPointPositionRelativeToLineSegment(p1, p2, p3);
    /*Проверяем, где находится точка p4 относительно отрезка p1-p2.*/
    const orientation2 = getPointPositionRelativeToLineSegment(p1, p2, p4);
    /*Проверяем, где находится точка p1 относительно отрезка p3-p4.*/
    const orientation3 = getPointPositionRelativeToLineSegment(p3, p4, p1);
    /*Проверяем, где находится точка p2 относительно отрезка p3-p4.*/
    const orientation4 = getPointPositionRelativeToLineSegment(p3, p4, p2);

    // Проверка общего случая пересечения
    // Общий случай: отрезки пересекаются, если точки p3 и p4 лежат по разные стороны от p1-p2,
    // и точки p1 и p2 лежат по разные стороны от p3-p4
    if ((orientation1 * orientation2 < 0) && (orientation3 * orientation4 < 0)) return true;

    // Проверка частных случаев (если отрезки касаются)
    /*Проверяется, лежит ли точка p3 на отрезке p1-p2*/
    if (orientation1 === 0 && isPointOnLineSegment(p1, p2, p3)) return true;
    /*Проверяется, лежит ли точка p4 на отрезке p1-p2*/
    if (orientation2 === 0 && isPointOnLineSegment(p1, p2, p4)) return true;
    /*Проверяется, лежит ли точка p1 на отрезке p3-p4*/
    if (orientation3 === 0 && isPointOnLineSegment(p3, p4, p1)) return true;
    /*Проверяется, лежит ли точка p2 на отрезке p3-p4*/
    if (orientation4 === 0 && isPointOnLineSegment(p3, p4, p2)) return true;

    return false;
};

function doPolygonsIntersect(vertices01, vertices02) {
    // Проверяем каждую сторону первого многоугольника с каждой стороной второго многоугольника
    for (let i = 0; i < vertices01.length; i++) {
        const p1 = vertices01[i];
        /*Чтобы замкнуть многоугольник, используется операция (i + 1) % vertices01.length. Это позволяет взять следующую вершину, а для последней вершины вернуться к первой.*/
        const p2 = vertices01[(i + 1) % vertices01.length];

        for (let j = 0; j < vertices02.length; j++) {
            const p3 = vertices02[j];
            const p4 = vertices02[(j + 1) % vertices02.length];

            if (doLineSegmentsIntersect(p1, p2, p3, p4)) {
                return true; // Стороны пересекаются
            }
        }
    }

    return false; // Стороны не пересекаются
};

/*Не забыть, когда один многоугольник внутри другого полностью*/