'use strict';
import { ctx, canvasData } from '../canvas/canvas.js';
import { graphicsHelper } from './graphicsHelper.js';

export const mathHelper = {
    /*Метод "getRandomIntFromInterval()" генерирует случайное целое число в указанном пределе.
    
    Метод "getRandomIntFromInterval()" принимает следующие параметры:
    1. "min" - это числовой параметр, содержащий нижний предел для генерации числа.
    2. "max" - это числовой параметр, содержащий верхний предел для генерации числа.

    Метод "getRandomIntFromInterval()" возвращает случайное целое число в указанном пределе.*/
    getRandomIntFromInterval: function (min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min);
    },

    /*Метод "isPointInsideNotRotatedRectangle()" определяет находится ли точка внутри ориентированного по осям
    прямоугольника.
    
    Метод "isPointInsideNotRotatedRectangle()" принимает следующие параметры:
    1. "minX" - это числовой параметр, содержащий минимальную X-координату прямоугольника.
    2. "maxX" - это числовой параметр, содержащий максимальную X-координату прямоугольника.
    3. "minY" - это числовой параметр, содержащий минимальную Y-координату прямоугольника.
    4. "maxY" - это числовой параметр, содержащий максимальную Y-координату прямоугольника.
    5. "pointX" - это числовой параметр, содержащий X-координату точки. 
    6. "pointY" - это числовой параметр, содержащий Y-координату точки. 
    
    Метод "isPointInsideNotRotatedRectangle()" возвращает:
    1. true, как знак того, что точка находится внутри ориентированного по осям прямоугольника.
    2. false, как знак того, что точка находится снаружи ориентированного по осям прямоугольника.*/
    isPointInsideNotRotatedRectangle: function (
        minX, maxX,
        minY, maxY,
        pointX, pointY,
    ) {
        return pointX >= minX && pointX <= maxX && pointY >= minY && pointY <= maxY ? true : false;
    },

    /*Метод "removeDuplicatesFromPoints()" удаляет дубликаты точек из массива точек.
    
    Метод "removeDuplicatesFromPoints()" принимает следующие параметры:
    1. "points" - это параметр в виде массива объектов, содержащих целочисленные координаты точек.

    Метод "removeDuplicatesFromPoints()" возвращает массива точек без дубликатов точек.*/
    removeDuplicatesFromPoints: function (points) {
        /*Избавляемся от дубликатов точек, если таковые имеются. Во внешнем цикле for перебираем все точки в массиве 
        "points".*/
        for (let i = 0; i < points.length; i++) {
            /*Во внутреннем цикле for перебираем только те точки в массиве "points", которые идут после точки, взятой 
            во внешнем цикле for.*/
            for (let j = i + 1; j < points.length; j++) {
                /*Если координаты точки, взятой во внешнем цикле for, равны координатам точки, взятой во внутреннем 
                цикле for, то удаляем точку, взятую во внутреннем цикле for. Поскольку в этом случае массив "points" 
                уменьшается на один элемент, то переменную-итератор "j" внутреннего цикла for уменьшаем на 1, чтобы не 
                пропустить какие-то элементы массива "points" при их дальнейшем переборе.*/
                if (points[i].x === points[j].x && points[i].y === points[j].y) {
                    points.splice(j, 1);
                    j--;
                };
            };
        };

        return points;
    },

    /*Метод "preparePolygonIntVerticesData()" случайно рассчитывает координаты вершин многоугольника в рамках указанной 
    области.
    
    Метод "preparePolygonIntVerticesData()" принимает следующие параметры:
    1. "numberOfVertices" - это числовой параметр, указывающий сколько вершин должно быть в многоугольнике.
    2. "x1" - это числовой параметр, указывающий минимальную X-координату области, в рамках которой должны быть вершины 
    многоугольника.
    3. "x2" - это числовой параметр, указывающий максимальную X-координату области, в рамках которой должны быть вершины 
    многоугольника.
    4. "y1" - это числовой параметр, указывающий минимальную Y-координату области, в рамках которой должны быть вершины 
    многоугольника.
    5. "y2" - это числовой параметр, указывающий максимальную Y-координату области, в рамках которой должны быть вершины 
    многоугольника.
    6. "clockwiseStepX" - это числовой параметр, указывающий максимальное расстояние сдвига по оси X вершин 
    многоугольника при движении по часовой стрелке по четвертям области, в рамках которой должны быть вершины 
    многоугольника.
    7. "clockwiseStepY" - это числовой параметр, указывающий максимальное расстояние сдвига по оси Y вершин 
    многоугольника при движении по часовой стрелке по четвертям области, в рамках которой должны быть вершины 
    многоугольника.
    8. "cellWidth" - это числовой параметр, указывающий ширину одной клетки в сетке холста.
    9. "cellHeight" - это числовой параметр, указывающий высоту одной клетки в сетке холста.
    10. "gridAligned" - это булев параметр, указывающий нужно ли выравнивать координаты вершин многоугольника по сетке.
    
    Логика работы метода "preparePolygonIntVerticesData()" следующая:
    1. Условно разбиваем на четыре четверти область, в рамках которой должны быть вершины многоугольника.
    2. Определяем сколько примерно вершин должно быть в каждой четверти области, в рамках которой должны быть вершины 
    многоугольника, исходя из общего количества вершин многоугольника.
    3. Рассчитываем первую координату многоугольника и располагаем ее примерно в верхней центральной части области, в
    рамках которой должны быть вершины многоугольника.
    4. Рассчитываем координаты остальных вершин многоугольника, двигаясь по часовой стрелке по четвертям области, в
    рамках которой должны быть вершины многоугольника.
    5. Выравниваем рассчитанные координаты вершин многоугольника по сетке, если необходимо.
    6. Корректируем рассчитанные координаты вершин многоугольника, выходящие за пределы области, в рамках которой должны
    быть вершины многоугольника.
    
    Нужно понимать, что качество результата работы этого метода во многом зависит от адекватно подобранных параметров.
    
    Метод "preparePolygonIntVerticesData()" возвращает массив объектов, содержащих рассчитанные координаты вершин 
    многоугольника.*/
    preparePolygonVerticesData: function (
        numberOfVertices,
        x1, x2,
        y1, y2,
        clockwiseStepX, clockwiseStepY,
        cellWidth, cellHeight,
        gridAligned
    ) {
        /*Создаем пустой массив "vertices" для заполнения его объектами, содержащими координаты вершин многоугольника.*/
        const vertices = [];

        /*Создаем переменные "currentX" и "currentY" для хранения X-координаты и Y-координаты текущей рассчитываемой 
        вершины многоугольника соответственно.*/
        let currentX;
        let currentY;

        /*Рассчитываем сколько примерно вершин должно быть в каждой четверти области, в рамках которой должны быть 
        вершины многоугольника. Полученный результат сохраняем в переменную "verticesPerQuarter". Это значение нужно,
        чтобы переходить при расчете координат вершин многоугольника из одной четверти области, в рамках которой
        должны быть вершины многоугольника, в следующую четверть этой области.*/
        const verticesPerQuarter = Math.ceil((numberOfVertices - 1) / 4);

        /*Создаем переменную "quarterStepCount" для обозначения в какой четверти области, в рамках которой должны быть 
        вершины многоугольника, мы проводим расчет координат вершин многоугольника.*/
        let quarterStepCount = 1;

        /*Рассчитываем координаты вершин многоугольника.*/
        for (let i = 1; i <= numberOfVertices; i++) {
            /*Координаты первой вершины многоугольника рассчитываем отдельно. Располагаем первую вершину многоугольника 
            примерно в верхней центральной части области, в рамках которой должны быть вершины многоугольника.*/
            if (i === 1) {
                /*Рассчитываем X-координату первой вершины многоугольника:
                1. "(x2 - x1) / 2) + x1" - находим центральную X-координату области, в рамках которой должны быть 
                вершины многоугольника.
                2. "+ this.randomIntFromInterval(-1 * cellWidth, cellWidth) + cellWidth * 3" - найденную X-координату 
                сдвигаем вправо случайно на 2-4 клетки, чтобы X-координата первой вершины многоугольника всегда 
                оказывалась в первой четверти области, в рамках которой должны быть вершины многоугольника.*/
                currentX = (x2 - x1) / 2 + x1
                    + this.getRandomIntFromInterval(-1 * cellWidth, cellWidth) + cellWidth * 3;

                /*Рассчитываем Y-координату первой вершины многоугольника:
                1) "y1" - берем верхнюю Y-координату области, в рамках которой должны быть вершины многоугольника.
                2) "+ this.randomIntFromInterval(Math.floor((y2 - y1) / 3), Math.floor((y2 - y1) / 2))" - взятую 
                Y-координату сдвигаем вниз случайно на расстояние из диапазона от 1/3 до 1/2 высоты области, в рамках 
                которой должны быть вершины многоугольника, чтобы первая вершина многоугольника всегда оказывалась в 
                указанной области.*/
                currentY = y1
                    + this.getRandomIntFromInterval(Math.floor((y2 - y1) / 3), Math.floor((y2 - y1) / 2));
            } else {
                /*Вершины многоугольника, кроме первой, рассчитываем при помощи движения по часовой стрелке по четвертям 
                области, в рамках которой должны быть вершины многоугольника.
                
                При расчете каждой вершины многоугольника определяем в какой четверти области, в рамках которой должны 
                быть вершины многоугольника, мы рассчитываем координаты вершин многоугольника:
                1 - Первая четверть.
                2 - Вторая четверть.
                3 - Третья четверть.
                4, 5 - Четвертая четверть.
                
                В каждой четверти области, в рамках которой должны быть вершины многоугольника, мы имитируем движение 
                координат вершин по часовой стрелке:
                1 - ↘ - Движение вправо и вниз.
                2 - ↙ - Движение влево и вниз.
                3 - ↖ - Движение влево и вверх.
                4, 5 - ↗ - Движение вправо и вверх.*/
                switch (quarterStepCount) {
                    /*Рассчитываем координаты вершин многоугольника в первой четверти области, в рамках которой должны 
                    быть вершины многоугольника.*/
                    case 1:
                        {
                            /*Берем X-координату предыдущей рассчитанной вершины многоугольника и случайно ее сдвигаем 
                            вправо минимум на 1 клетку, максимум до значения переменной "clockwiseStepX".*/
                            currentX = vertices[i - 2].x + this.getRandomIntFromInterval(cellWidth, clockwiseStepX);

                            /*Берем Y-координату предыдущей рассчитанной вершины многоугольника и случайно ее сдвигаем 
                            вниз минимум на 1 клетку, максимум до значения переменной "clockwiseStepY".*/
                            currentY = vertices[i - 2].y + this.getRandomIntFromInterval(cellHeight, clockwiseStepY);
                            break;
                        };

                    /*Рассчитываем координаты вершин многоугольника во второй четверти области, в рамках которой должны 
                    быть вершины многоугольника.*/
                    case 2:
                        {
                            /*Берем X-координату предыдущей рассчитанной вершины многоугольника и случайно ее сдвигаем 
                            влево минимум на 1 клетку, максимум до значения переменной "clockwiseStepX".*/
                            currentX = vertices[i - 2].x - this.getRandomIntFromInterval(cellWidth, clockwiseStepX);

                            /*Берем Y-координату предыдущей рассчитанной вершины многоугольника и случайно ее сдвигаем 
                            вниз минимум на 1 клетку, максимум до значения переменной "clockwiseStepY".*/
                            currentY = vertices[i - 2].y + this.getRandomIntFromInterval(cellHeight, clockwiseStepY);
                            break;
                        };

                    /*Рассчитываем координаты вершин многоугольника в третьей четверти области, в рамках которой должны 
                    быть вершины многоугольника.*/
                    case 3:
                        {
                            /*Берем X-координату предыдущей рассчитанной вершины многоугольника и случайно ее сдвигаем 
                            влево минимум на 1 клетку, максимум до значения переменной "clockwiseStepX".*/
                            currentX = vertices[i - 2].x - this.getRandomIntFromInterval(cellWidth, clockwiseStepX);

                            /*Берем Y-координату предыдущей рассчитанной вершины многоугольника и случайно ее сдвигаем 
                            вверх минимум на 1 клетку, максимум до значения переменной "clockwiseStepY".*/
                            currentY = vertices[i - 2].y - this.getRandomIntFromInterval(cellHeight, clockwiseStepY);
                            break;
                        };

                    /*Рассчитываем координаты вершин многоугольника в четвертой четверти области, в рамках которой 
                    должны быть вершины многоугольника. Если мы имеем нечетное количество вершин, то под конец расчета 
                    координат вершин многоугольника мы можем перейти в несуществующую пятую четверть области, в рамках 
                    которой должны быть вершины многоугольника. Чтобы это не вызывало проблем рассчитываем координаты 
                    вершин многоугольника в этой пятой четверти таким же способом, как и в четвертой четверти.*/
                    case 4:
                    case 5:
                        {
                            /*Берем X-координату предыдущей рассчитанной вершины многоугольника и случайно ее сдвигаем 
                            вправо минимум на 1 клетку, максимум до значения переменной "clockwiseStepX".*/
                            currentX = vertices[i - 2].x + this.getRandomIntFromInterval(cellWidth, clockwiseStepX);

                            /*Проверяем не получилось ли так, что рассчитанная X-координата вершины многоугольника 
                            больше или равна X-координате первой вершины многоугольника. Если это так, то на 1 клетку
                            вправо сдвигаем рассчитанную X-координату вершины многоугольника и X-координату предыдущей
                            рассчитанной вершины многоугольника. Эта проверка нужна, чтобы не было склеек вершин и
                            сгибаний многоугольника вокруг одной вершины.*/
                            while (currentX >= vertices[0].x) {
                                vertices[i - 2].x = vertices[i - 2].x - cellWidth;
                                currentX = currentX - cellWidth;
                            };

                            /*Берем Y-координату предыдущей рассчитанной вершины многоугольника и случайно ее сдвигаем 
                            вверх минимум на 1 клетку, максимум до значения переменной "clockwiseStepY".*/
                            currentY = vertices[i - 2].y - this.getRandomIntFromInterval(cellHeight, clockwiseStepY);
                            break;
                        };

                    default:
                        break;
                };
            };

            /*Если указано, что нужно выравнивать координаты вершин многоугольника по сетке, то делаем это.*/
            if (gridAligned) {
                /*Выравниваем рассчитанную X-координату вершины многоугольника по сетке. Делим рассчитанную X-координату 
                вершины многоугольника на ширину клетки и находим остаток.*/
                if (currentX % cellWidth >= cellWidth / 2) {
                    /*Если остаток больше или равен половине ширины клетки, то округляем рассчитанную X-координату 
                    вершины многоугольника по верху (например, 382 -> 400):
                    1. "Math.trunc(currentX / cellWidth)" - находим целую часть от деления (например, 382 / 50 = 7).
                    2. "+ 1" - прибавляем к целой части от деления 1, чтобы потом полученную целую часть умножить на 
                    ширину клетки (например, 7 + 1 = 8).
                    3. "* cellWidth" - полученную целую часть умножаем на ширину клетки (например, 8 * 50 = 400).*/
                    currentX = (Math.trunc(currentX / cellWidth) + 1) * cellWidth;
                } else {
                    /*Если остаток меньше половины ширины клетки, то округляем рассчитанную X-координату вершины 
                    многоугольника по низу (например, 354 -> 350):
                    1. "Math.trunc(currentX / cellWidth)" - находим целую часть от деления (например, 354 / 50 = 7).
                    2. "* cellWidth" - полученную целую часть умножаем на ширину клетки (например, 7 * 50 = 350).*/
                    currentX = Math.trunc(currentX / cellWidth) * cellWidth;
                };

                /*Выравниваем рассчитанную Y-координату вершины многоугольника по сетке аналогичным способом.*/
                if (currentY % cellHeight >= cellHeight) {
                    currentY = (Math.trunc(currentY / cellHeight) + 1) * cellHeight;
                } else {
                    currentY = Math.trunc(currentY / cellHeight) * cellHeight;
                };
            };

            /*Корректируем рассчитанную X-координату вершины многоугольника если она выходит за пределы области, в 
            рамках которой должны быть вершины многоугольника.
    
            Если рассчитанная X-координата вершины многоугольника больше максимальной X-координаты области, в рамках 
            которой должны быть вершины многоугольника, то делаем так, чтобы рассчитанная X-координата вершины 
            многоугольника была равна максимальной X-координате упомянутой области.*/
            if (currentX >= x2) { currentX = x2 };
            /*Если рассчитанная X-координата вершины многоугольника меньше минимальной X-координаты области, в рамках 
            которой должны быть вершины многоугольника, то делаем так, чтобы рассчитанная X-координата вершины 
            многоугольника была равна минимальной X-координате упомянутой области.*/
            if (currentX <= x1) { currentX = x1 };

            /*Корректируем рассчитанную Y-координату вершины многоугольника если она выходит за пределы области, в 
            рамках которой должны быть вершины многоугольника, аналогичным способом.*/
            if (currentY >= y2) { currentY = y2 };
            if (currentY <= y1) { currentY = y1 };

            /*Корректируем рассчитанную X-координату предыдущей рассчитанной вершины многоугольника если она выходит за 
            пределы области, в рамках которой должны быть вершины многоугольника, аналогичным способом. Эта проверка 
            нужна если при расчете X-координат в четвертой четверти области, в рамках которой должны быть вершины 
            многоугольника, нам пришлось изменить уже рассчитанную X-координату предыдущей рассчитанной вершины 
            многоугольника и измененная X-координата вышла за пределы упомянутой области.*/
            if (vertices[i - 2]) {
                if (vertices[i - 2].x >= x2) { vertices[i - 2].x = x2 };
                if (vertices[i - 2].x <= x1) { vertices[i - 2].x = x1 };
            };

            /*Рассчитав и откорректировав координаты вершины многоугольника добавляем ее в массив "vertices".*/
            vertices.push({ x: currentX, y: currentY });

            /*Проверяем не нужно ли для расчета координат следующей вершины многоугольника перейти в следующую четверть
            области, в рамках которой должны быть вершины многоугольника. Мы делаем такой переход только если количество 
            уже рассчитанных вершин многоугольника кратно примерному количеству вершин в каждой четверти упомянутой 
            области из переменной "verticesPerQuarter". Такая логика позволяет рассчитывать примерно одинаковое
            количество вершин многоугольника в каждой четверти области, в рамках которой должны быть вершины 
            многоугольника.*/
            if (i % verticesPerQuarter === 0) { quarterStepCount++ };
        };

        /*Отрисовываем область, в рамках которой должны быть вершины многоугольника. Это нужно только для 
        тестирования.*/
        // ctx.lineWidth = 1;
        // ctx.strokeStyle = 'red';
        // ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);

        /*Проверяем не получилось ли у нас вершин с одинаковыми координатами. Это нужно только для тестирования.*/
        // for (let i = 0; i < vertices.length; i++) {
        //     for (let j = i + 1; j < vertices.length; j++) {
        //         if (vertices[i].x === vertices[j].x && vertices[i].y === vertices[j].y) {
        //             console.log(`WARNING Duplicate Vertices ${i} and ${j}`);
        //         };
        //     };
        // };

        /*Выводим информацию о вершинах многоугольника в консоль. Это нужно только для тестирования.*/
        // console.log(`Vertices' Coordinates:`);
        // console.log(vertices);
        // console.log('--------------------------------------');

        /*Возвращаем массив объектов, содержащих рассчитанные координаты вершин многоугольника.*/
        return vertices;
    },

    /*Метод "findIntPointOnLineSegment()" находит точки с целочисленными координатами на отрезке, используя линейную 
    интерполяцию. Линейная интерполяция - это метод нахождения промежуточных значений между двумя известными точками на 
    прямой линии.

    Метод "findIntPointOnLineSegment()" принимает следующие параметры:
    1. "x1" - это числовой параметр, указывающий X-координату первой конечной точки отрезка.
    2. "y1" - это числовой параметр, указывающий Y-координату первой конечной точки отрезка.
    3. "x2" - это числовой параметр, указывающий X-координату второй конечной точки отрезка.
    4. "y2" - это числовой параметр, указывающий Y-координату второй конечной точки отрезка.

    Логика работы метода "findIntPointOnLineSegment()" следующая:
    1. Находим длину отрезка между двумя указанными точками.
    2. Находим количество шагов интерполяции, то есть количество точек на отрезке.
    3. Проходим по шагам интерполяции и вычисляем целочисленные координаты точек на отрезке.
    4. Избавляемся от дубликатов точек, если таковые имеются.

    Метод "findIntPointOnLineSegment()" возвращает массив объектов, содержащих целочисленные координаты найденных точек 
    на отрезке.*/
    findIntPointsOnLineSegment: function (x1, y1, x2, y2) {
        /*Создаем пусстой массив "points" для заполнения его объектами, содержащими целочисленные координаты найденных 
        точек на отрезке.*/
        let points = [];

        /*Находим разность X-координат конечных точек отрезка и сохраняем ее в переменной "dx".*/
        const dx = x2 - x1;
        /*Находим разность Y-координат конечных точек отрезка и сохраняем ее в переменной "dy".*/
        const dy = y2 - y1;
        /*Находим расстояние между конечными точками отрезка по формуле расстояния между точками, которая работает на 
        основе теоремы Пифагора, и сохраняем его в переменной "distance".*/
        const distance = Math.sqrt(dx * dx + dy * dy);

        /*Находим количество шагов интерполяции, то есть количество точек на отрезке, путем округления длины отрезка 
        понизу, и сохраняем его в переменной "steps".*/
        const steps = Math.floor(distance);

        /*Проходим по шагам интерполяции и вычисляем целочисленные координаты точек на отрезке.*/
        for (let i = 0; i <= steps; i++) {
            /*Вычисляем параметр "progress", который принимает значения от 0 до 1. Параметр "progress" - это параметр 
            параметризации, описывающий положение точки на отрезке. Например, если у нас 13 шагов интерполяции, то 
            параметр "progress" будет принимать значения от 0/13 до 13/13.*/
            const progress = i / steps;

            /*Высчитываем целочисленную X-координату текущей точки на отрезке.*/
            const x = Math.round(x1 + dx * progress);
            /*Высчитываем целочисленную Y-координату текущей точки на отрезке.*/
            const y = Math.round(y1 + dy * progress);

            /*Добавляем объект с высчитанными целочисленными координатами текущей точки в массив "points".*/
            points.push({ x, y });
        };

        /*Избавляемся от дубликатов точек, если таковые имеются, при помощи метода "removeDuplicatesFromPoints()".*/
        points = this.removeDuplicatesFromPoints(points);

        /*Выводим информацию о точках на отрезке в консоль. Это нужно только для тестирования.*/
        // console.log(`${points.length} points on the line segment:`);
        // console.log(points);
        // console.log('--------------------------------------');

        /*Возвращаем массив объектов, содержащих целочисленные координаты найденных точек на отрезке.*/
        return points;
    },

    /*Метод "findIntPointsOnPolygonEdges()" находит точки с целочисленными координатами на всех сторонах многоугольника.
    
    Метод "findIntPointsOnPolygonEdges()" принимает следующие параметры:
    1. "vertices" - это параметр в виде массива объектов, содержащих целочисленные координаты последовательно указанных 
    вершин многоугольника.

    Логика работы метода "findIntPointsOnPolygonEdges()" следующая:
    1. Избавляемся от дубликатов вершин многоугольника, если таковые имеются.
    2. Перебираем все соседние пары вершины многоугольника.
    3. Находим точки с целочисленными координатами на каждой стороне многоугольника.
    4. Избавляемся от дубликатов точек, если таковые имеются.

    Метод "findIntPointsOnPolygonEdges()" возвращает массив объектов, содержащих целочисленные координаты точек на 
    каждой стороне многоугольника.*/
    findIntPointsOnPolygonEdges: function (vertices) {
        /*Избавляемся от дубликатов вершин многоугольника, если таковые имеются, при помощи метода 
        "removeDuplicatesFromPoints()".*/
        vertices = this.removeDuplicatesFromPoints(vertices);

        /*Создаем пустой массив "points" для заполнения его объектами, содержащими целочисленные координаты найденных
        точек на сторонах многоугольника.*/
        let points = [];

        /*Перебираем все соседние пары вершины многоугольника (например, если у нас 12 вершин многоугольника, то 
        перебираем его вершины в таком порядке: 1 и 2 -> 2 и 3 -> 3 и 4 -> ... -> 13 и 1), чтобы при помощи метода 
        "findIntPointOnLineSegment()" найти точки с целочисленными координатами на каждой стороне многоугольника.*/
        for (let i = 0; i < vertices.length; i++) {
            /*Каждый цикл переменная "i" представляет номер первой вершины многоугольника в паре, а переменная "k" номер
            второй вершины многоугольника в паре.*/
            let k;

            /*Если текущая вершина "i" многоугольника не является последней вершиной многоугольника в массиве 
            "vertices", то номер второй вершины "k" многоугольника равен номеру текущей вершины "i" многоугольника, 
            увеличенному на 1, что означает соседнюю вершину многоугольника для вершины "i" многоугольника.
            
            Если же текущая вершина "i" многоугольника является последней вершиной многоугольника в массиве "vertices",
            то для того, чтобы найти целочисленные координаты точек между последней и первой вершинами многоугольника, 
            номер второй вершины "k" многоугольника равен 0, что означает первую вершину многоугольника из массива 
            "vertices".*/
            if (i !== vertices.length - 1) { k = i + 1 } else { k = 0 };

            /*При помощи метода "findIntPointOnLineSegment()" находим массив объектов, содержащих целочисленные 
            координаты точек на стороне многоугольника, и добавляем эти объекты в массив "points".*/
            points.push(
                ...this.findIntPointsOnLineSegment(vertices[i].x, vertices[i].y, vertices[k].x, vertices[k].y)
            );
        };

        /*Избавляемся от дубликатов точек, если таковые имеются, при помощи метода "removeDuplicatesFromPoints()".*/
        points = this.removeDuplicatesFromPoints(points);

        /*Отрисовываем найденные точки. Это нужно только для тестирования.*/
        // for (let i = 0; i < points.length; i++) {
        //     ctx.fillStyle = graphicsHelper.getRandomColor();
        //     ctx.fillRect(points[i].x, points[i].y, 5, 5);
        // };

        /*Выводим информацию о точках на каждой стороне многоугольника в консоль. Это нужно только для тестирования.*/
        // console.log(`${points.length} points on the polygon's edges:`);
        // console.log(points);
        // console.log('--------------------------------------');

        /*Возвращаем массив объектов, содержащих целочисленные координаты найденных точек на каждой стороне 
        многоугольника.*/
        return points;
    },

    /*Метод "isPointInsidePolygon()" определяет находится ли точка внутри многоугольника, используя метод луча.

    Метод луча примерно работает следующим образом:
    1. Из указанной точки пускаем луч в правую или левую сторону (в нашем случае - в правую). 
    2. Подсчитываем количество пересечений луча со сторонами многоугольника.
    3. Если подсчитанное количество пересечений нечетное, то это означает, что точка находится внутри многоугольника, 
    иначе точка находится снаружи многоугольника.*

    Метод "isPointInsidePolygon()" принимает следующие параметры:
    1. "point" - это параметр в виде объекта, содержащий целочисленные координаты точки для определения находится ли 
    она внутри многоугольника.
    2. "vertices" - это параметр в виде массива объектов, содержащих целочисленные координаты последовательно указанных 
    вершин многоугольника.

    Логика работы метода "isPointInsidePolygon()" следующая:
    1. Избавляемся от дубликатов вершин многоугольника, если таковые имеются.
    2. Проверяем не совпадает ли точка с одной из вершин многоугольника.
    3. Проверяем не находится ли точка снаружи "ограничивающей коробки" многоугольника.
    4. Находим точку пересечения луча и максимальной X-координатой среди вершин многоугольника, так как пускаем луч 
    вправо.
    5. Находим точки с целочисленными координатами на отрезке луча.
    6. Находим массив объектов, содержащих целочисленные координаты точек на каждой стороне многоугольника.
    7. Перебираем точки на отрезке луче и точки на сторонах многоугольника, сохраняя все совпадающие точки в массив.
    8. Перебираем точки в упомянутом массиве с конца в начало, чтобы убрать соседние точки пересечения отрезка луча и 
    сторон многоугольника, которые находятся на одной и той же Y-координате, но имеют X-координаты отличающиеся друг от 
    друга на 1.
    9. Проверяем не получается ли так, что все точки в упомянутом массиве совпадают с вершинами многоугольника. Если это 
    так, то возвращаем false, как знак того, что точка находится снаружи многоугольника.
    10. Если количество пересечений отрезка луча и сторон многоугольника нечетное, возвращаем true, как знак того, что 
    точка находится внутри многоугольника, иначе возвращаем false, как знак того, что точка находится снаружи 
    многоугольника.

    Метод "isPointInsidePolygon()" возвращает:
    1. true, как знак того, что точка находится внутри многоугольника.
    2. false, как знак того, что точка находится снаружи многоугольника.*/
    isPointInsidePolygon: function (point, vertices) {
        /*Избавляемся от дубликатов вершин многоугольника, если таковые имеются, при помощи метода 
        "removeDuplicatesFromPoints()".*/
        vertices = this.removeDuplicatesFromPoints(vertices);

        /*Проверяем не совпадает ли точка с одной из вершин многоугольника. Если это так, то возвращаем true, как знак 
        того, что точка находится внутри многоугольника.*/
        for (let i = 0; i < vertices.length; i++) {
            if (point.x === vertices[i].x && point.y === vertices[i].y) { return true };
        };

        /*Создаем переменные "minX", "maxX", "minY" и "maxY" для хранения минимальной X-координаты, максимальной
        X-координаты, минимальной Y-координаты и максимальной Y-координаты среди всех вершин многоугольника 
        соответственно.*/
        let minX = vertices[0].x;
        let maxX = vertices[0].x;
        let minY = vertices[0].y;
        let maxY = vertices[0].y;

        /*Находим минимальную X-координату, максимальную X-координату, минимальную Y-координату и максимальную 
        Y-координату среди всех вершин многоугольника соответственно.*/
        for (let i = 0; i < vertices.length; i++) {
            if (vertices[i].x < minX) { minX = vertices[i].x };
            if (vertices[i].x > maxX) { maxX = vertices[i].x };
            if (vertices[i].y < minY) { minY = vertices[i].y };
            if (vertices[i].y > maxY) { maxY = vertices[i].y };
        };

        /*Проверяем не находится ли точка снаружи "ограничивающей коробки" многоугольника при помощи метода 
        "isPointInsideNotRotatedRectangle()". Если это так, то возвращаем false, как знак того, что точка находится 
        снаружи многоугольника.*/
        if (
            !this.isPointInsideNotRotatedRectangle(
                minX, maxX,
                minY, maxY,
                point.x, point.y
            )
        ) {
            return false;
        };

        /*Поскольку наш холст имеет ограниченные размеры, то нам не нужен весь луч, а только лишь его отрезок,
        ограниченный максимальной X-координатой среди вершин многоугольника. Поэтому формируем координаты для точки 
        пересечения луча и максимальной X-координатой среди вершин многоугольника, так как пускаем луч вправо, и 
        сохраняем эти данные в переменной "rayIntersectionPoint".*/
        const rayCanvasIntersectionPoint = { x: maxX + canvasData.cellWidth, y: point.y };

        /*Находим массив объектов, содержащих целочисленные координаты точек на отрезке луча, при помощи метода 
        "findIntPointsOnLineSegment()" и сохраняем его в переменной "rayPoints".*/
        const rayPoints = this.findIntPointsOnLineSegment(
            point.x, point.y,
            rayCanvasIntersectionPoint.x, rayCanvasIntersectionPoint.y
        );

        /*Находим массив объектов, содержащих целочисленные координаты точек на каждой стороне многоугольника, при 
        помощи метода "findIntPointsOnPolygonEdges()" и сохраняем его в переменную "pointsOnPolygonEdges".*/
        const pointsOnPolygonEdges = this.findIntPointsOnPolygonEdges(vertices);

        /*Создаем массив "intersectionPoints" для заполнения его объектами, содержащими целочисленные координаты точек 
        пересечений отрезка луча и сторон многоугольника.*/
        const intersectionPoints = [];

        /*Внешним циклом for перебираем точки на отрезке луче.*/
        for (let i = 0; i < rayPoints.length; i++) {
            /*Внутренним циклом for перебираем точки на сторонах многоугольника.*/
            for (let j = 0; j < pointsOnPolygonEdges.length; j++) {
                /*Если взятая точка на отрезке луча совпадает с взятой точкой на стороне многоугольника, то добавляем
                эту точку в массив "intersectionPoints".*/
                if (rayPoints[i].x === pointsOnPolygonEdges[j].x && rayPoints[i].y === pointsOnPolygonEdges[j].y) {
                    intersectionPoints.push(pointsOnPolygonEdges[j]);

                    /*Выводим зарегистрированное пересечение в консоль. Это нужно только для тестирования.*/
                    // console.log(`Intersection registered: Ray point (${rayPoints[i].x}, ${rayPoints[i].y}) and Point on an edge of the polygon (${pointsOnPolygonEdges[j].x}, ${pointsOnPolygonEdges[j].y})`);
                    // console.log('--------------------------------------');

                    /*Отрисовываем желтым цветом взятую точку на отрезке луча. Это нужно только для тестирования.*/
                    // ctx.fillStyle = 'yellow';
                    // ctx.fillRect(rayPoints[i].x, rayPoints[i].y, 10, 10);

                    /*Отрисовываем зеленым цветом взятую точку на стороне многоугольника. Это нужно только для 
                    тестирования.*/
                    // ctx.fillStyle = 'green';
                    // ctx.fillRect(pointsOnPolygonEdges[j].x, pointsOnPolygonEdges[j].y, 5, 5);
                };
            };
        };

        /*Выводим точки пересечений отрезка луча и сторон многоугольника в консоль. Это нужно только для тестирования.*/
        // console.log('intersectionPoints:');

        // for (let i = 0; i < intersectionPoints.length; i++) {
        //     console.log(intersectionPoints[i].x);
        //     console.log(intersectionPoints[i].y);
        //     console.log('------');
        // };

        // console.log('--------------------------------------');

        /*Перебираем элементы в массиве "intersectionPoints" с конца в начало, чтобы убрать соседние точки пересечения 
        отрезка луча и сторон многоугольника, которые находятся на одной и той же Y-координате, но имеют X-координаты 
        отличающимися друг от друга на 1. Эта проверка нужна, чтобы избежать случаев, когда какая-то сторона 
        многоугольника или часть стороны многоугольника совпадает с отрезком луча или частью отрезка луча. Эта проверка 
        игнорирует первую точку в массиве "intersectionPoints", так как для нее нет пары в виде предыдущей соседней 
        точки.*/
        for (let i = intersectionPoints.length - 1; i > 0; i--) {
            if (
                intersectionPoints[i].y === intersectionPoints[i - 1].y &&
                intersectionPoints[i].x === intersectionPoints[i - 1].x + 1
            ) {
                intersectionPoints.pop();
            };
        };

        /*Создаем переменную "pointsEqualToPolygonVerticesCount" для хранения значения, обозначающего сколько точек в
        массиве "intersectionPoints" совпадают с какими-либо вершинами многоугольника.*/
        let pointsEqualToPolygonVerticesCount = 0;

        /*Внешним циклом for перебираем точки в массиве "intersectionPoints".*/
        for (let i = 0; i < intersectionPoints.length; i++) {
            /*Внутренним циклом for перебираем вершины многоугольника.*/
            for (let j = 0; j < vertices.length; j++) {
                /*Если точка из массива "intersectionPoints" совпадает с вершиной многоугольника, то засчитываем это 
                путем увеличения значения переменной "pointsEqualToPolygonVerticesCount" на 1.*/
                if (intersectionPoints[i].x === vertices[j].x && intersectionPoints[i].y === vertices[j].y) {
                    pointsEqualToPolygonVerticesCount++;
                    break;
                };
            };
        };

        /*Проверяем не получается ли так, что все точки в массиве "intersectionPoints" совпадают с вершинами 
        многоугольника, при этом отрезок луча находится либо выше минимальной Y-координаты многоугольника, либо ниже 
        максимальной Y-координаты. Если это так, то возвращаем false, как знак того, что точка находится снаружи 
        многоугольника.*/
        if (
            (point.y <= minY || point.y >= maxY) &&
            intersectionPoints.length === pointsEqualToPolygonVerticesCount
        ) { return false };

        /*Выводим информацию о точке в консоль. Это нужно только для тестирования.*/
        // console.log('Point:');
        // console.log(point);
        // console.log('--------------------------------------');

        /*Выводим точки пересечений луча и сторон многоугольника. Это нужно только для тестирования.*/
        // console.log('intersectionPoints:');
        // console.log(intersectionPoints);
        // console.log('--------------------------------------');

        /*Выводим информацию о количестве пересечений отрезка луча и сторон многоугольника. Это нужно только для 
        тестирования.*/
        // console.log(`Intersections between the ray and the polygon's edges: ${intersectionPoints.length}`);
        // console.log('--------------------------------------');

        /*Выводим информацию о точках на отрезке луча в консоль. Это нужно только для тестирования.*/
        // console.log(`${rayPoints.length} points on the ray:`);
        // console.log(rayPoints);
        // console.log('--------------------------------------');

        /*Отрисовываем луч из указанной точки в правую сторону. Это нужно только для тестирования.*/
        // ctx.fillStyle = 'purple';
        // ctx.fillRect(point.x, point.y, canvasData.canvasWidth, 5);

        /*Если количество пересечений отрезка луча и сторон многоугольника нечетное, то это означает, что точка 
        находится внутри многоугольника, поэтому возвращаем true, иначе возвращаем false, как знак того, что точка 
        находится снаружи многоугольника.*/
        if (intersectionPoints.length % 2 !== 0) { return true } else { return false };
    },

    /*Метод "getCrossProduct()" рассчитывает векторное произведение двух векторов.
    
    В двумерном пространстве векторное произведение двух векторов не определено в классическом понимании, так как 
    векторное произведение существует только в трехмерном пространстве. Однако в двумерном случае можно рассмотреть 
    псевдоскалярное произведение, которое возвращает число, а не вектор. Это число соответствует третьей компоненте 
    векторного произведения, если бы векторы были дополнены до трехмерных. Векторное произведение двух векторов в 
    двумерном пространстве - это число, которое показывает, как эти векторы ориентированы относительно друг друга.
    
    Для двух векторов AB = (Bx - Ax, By - Ay) и CD = (Dx - Cx, Dy - Cy) векторное произведение вычисляется по формуле:
    AB * CD = (Bx - Ax) * (Dy - Cy) - (By - Ay) * (Dx - Cx).
    
    Метод "getCrossProduct()" принимает следующие параметры:
    1. "v1StartPointX" - это числовой параметр, содержащий X-координату начальной точки первого вектора.
    2. "v1StartPointY" - это числовой параметр, содержащий Y-координату начальной точки первого вектора.
    3. "v1EndPointX" - это числовой параметр, содержащий X-координату конечной точки первого вектора.
    4. "v1EndPointY" - это числовой параметр, содержащий Y-координату конечной точки первого вектора.
    5. "v2StartPointX" - это числовой параметр, содержащий X-координату начальной точки второго вектора.
    6. "v2StartPointY" - это числовой параметр, содержащий Y-координату начальной точки второго вектора.
    7. "v2EndPointX" - это числовой параметр, содержащий X-координату конечной точки второго вектора.
    8. "v2EndPointY" - это числовой параметр, содержащий Y-координату конечной точки второго вектора.
    
    Метод "getCrossProduct()" возвращает величину векторного произведения двух векторов.*/
    getCrossProduct: function (
        v1StartPointX, v1StartPointY, v1EndPointX, v1EndPointY,
        v2StartPointX, v2StartPointY, v2EndPointX, v2EndPointY
    ) {
        return (v1EndPointX - v1StartPointX) * (v2EndPointY - v2StartPointY) -
            (v1EndPointY - v1StartPointY) * (v2EndPointX - v2StartPointX);
    },

    /*Метод "getPointPositionRelativeToLineSegment()" определяет положение точки относительно прямой, содержащей 
    отрезок, заданный двумя точками, используя геометрический смысл векторного произведения двух векторов. 
    
    Геометрический смысл векторного произведения двух векторов на примере точки P и прямой, содержащей отрезок AB:
    1. Если векторное произведение двух векторов AB и AP положительное, то это означает, что:
        1) Точка P находится слева от прямой, содержащей отрезок AB.
        2) Вектор AP "повернут" относительно вектора AB против часовой стрелки.

    2. Если векторное произведение двух векторов AB и AP отрицательное, то это означает, что:
        1) Точка P находится справа от прямой, содержащей отрезок AB.
        2) Вектор AP "повернут" относительно вектора AB по часовой стрелке.

    3. Если векторное произведение двух векторов AB и AP равно нулю, то это означает, что:
        1) Точка P лежит на прямой, содержащей отрезок AB.
        2) Векторы AB и AP коллинеарны, то есть лежат на одной прямой.

    Метод "getPointPositionRelativeToLineSegment()" принимает следующие параметры:
    1. "startPointX" - это числовой параметр, содержащий X-координату начальной точки вектора.
    2. "startPointY" - это числовой параметр, содержащий Y-координату начальной точки вектора.
    3. "endPointX" - это числовой параметр, содержащий X-координату конечной точки вектора.
    4. "endPointY" - это числовой параметр, содержащий Y-координату конечной точки вектора.
    5. "pointX" - это числовой параметр, содержащий X-координату точки.
    6. "pointY" - это числовой параметр, содержащий Y-координату точки.

    Метод "getPointPositionRelativeToLineSegment()" возвращает:
    1. 0, как знак того, что точка находится на прямой, содержащей отрезок.
    2. 1, как знак того, что точка находится слева от прямой, содержащей отрезок.
    3. -1, как знак того, что точка находится справа от прямой, содержащей отрезок.*/
    getPointPositionRelativeToLineSegment: function (
        startPointX, startPointY, endPointX, endPointY,
        pointX, pointY
    ) {
        const crossProduct = this.getCrossProduct(
            startPointX, startPointY, endPointX, endPointY,
            startPointX, startPointY, pointX, pointY
        );

        /*Создаем переменную "epsilon", которая обозначает символ ε (эпсилон), используемый для обозначения 
        положительного сколь угодно малого вещественного числа. При помощи нее мы устанавливаем порог для учета
        погрешности вычислений.
        
        1e-12 это научная запись числа 1×10^(−12), то есть 0.000 000 000 001 (одна триллионная). Это очень маленькое 
        число, которое используется как порог для учета погрешности вычислений.

        Почему используется 1e-12:
        1. Проблема точности вычислений. В компьютерах числа с плавающей запятой имеют ограниченную точность. Из-за 
        этого результат вычислений может быть не точным, а лишь приближенным. Например, вместо нуля может получиться 
        очень маленькое число, например, 1e-15.

        2. Порог погрешности. Чтобы учесть эту погрешность, вместо строгого сравнения с нулем используется сравнение с 
        очень маленьким числом, например, 1e-12. Если величина векторного произведения двух векторов меньше 1e-12, то 
        она считается "практически нулевой", и точка считается лежащей на прямой, содержащей отрезок.

        Переменная "epsilon" нужна для определения коллинеарности. Если векторное произведение двух векторов равно нулю, 
        то это означает, что эти векторы коллинеарны. Однако из-за погрешности вычислений результат может быть не точно 
        нулевым, а очень близким к нулю. Поэтому мы используем порог 1e-12, чтобы учесть эту погрешность.

        Например, предположим, что векторное произведение двух векторов равно 1e-14. Это очень близкое к нулю значение, 
        которое меньше, чем 1e-12. С практической точки зрения можно считать, что точка лежит на прямой. Но если бы мы 
        использовали строгое сравнение с нулем, то результат был бы false, что было бы неправильно.*/
        const epsilon = 1e-12;

        /*Если векторное произведение двух векторов, учитывая погрешность, равно нулю, то это означает, что точка 
        находится на прямой, содержащей отрезок. В этом случае возвращаем 0, как знак того, что точка находится на
        прямой, содержащей отрезок.*/
        if (Math.abs(crossProduct) < epsilon) return 0;
        /*Если векторное произведение двух векторов, учитывая погрешность, больше нуля, то это означает, что точка 
        находится слева от прямой, содержащей отрезок. В этом случае возвращаем 1, как знак того, что точка находится
        слева от прямой, содержащей отрезок.*/
        if (crossProduct > 0) return 1;
        /*Если векторное произведение двух векторов, учитывая погрешность, меньше нуля, то это означает, что точка 
        находится справа от прямой, содержащей отрезок. В этом случае возвращаем -1, как знак того, что точка находится
        справа от прямой, содержащей отрезок.*/
        return -1;
    },

    /*Метод "getDotProduct()" рассчитывает скалярное произведения двух векторов.
    
    Скалярное произведение двух векторов - это число, которое показывает, насколько один вектор "проецируется" на 
    другой.

    Для двух векторов AB = (Bx - Ax, By - Ay) и CD = (Dx - Cx, Dy - Cy) скалярное произведение вычисляется по формуле:
    AB * CD = (Bx - Ax) * (Dx - Cx) + (By - Ay) * (Dy - Cy).
    
    Метод "getDotProduct()" принимает следующие параметры:
    1. "v1StartPointX" - это числовой параметр, содержащий X-координату начальной точки первого вектора.
    2. "v1StartPointY" - это числовой параметр, содержащий Y-координату начальной точки первого вектора.
    3. "v1EndPointX" - это числовой параметр, содержащий X-координату конечной точки первого вектора.
    4. "v1EndPointY" - это числовой параметр, содержащий Y-координату конечной точки первого вектора.
    5. "v2StartPointX" - это числовой параметр, содержащий X-координату начальной точки второго вектора.
    6. "v2StartPointY" - это числовой параметр, содержащий Y-координату начальной точки второго вектора.
    7. "v2EndPointX" - это числовой параметр, содержащий X-координату конечной точки второго вектора.
    8. "v2EndPointY" - это числовой параметр, содержащий Y-координату конечной точки второго вектора.
    
    Метод "getDotProduct()" возвращает величину скалярного произведения двух векторов.*/
    getDotProduct: function (
        v1StartPointX, v1StartPointY, v1EndPointX, v1EndPointY,
        v2StartPointX, v2StartPointY, v2EndPointX, v2EndPointY
    ) {
        return (v1EndPointX - v1StartPointX) * (v2EndPointX - v2StartPointX) +
            (v1EndPointY - v1StartPointY) * (v2EndPointY - v2StartPointY);
    },

    /*Метод "getVectorsRelativeDirection()" определяет направление двух векторов относительно друг друга, используя 
    геометрический смысл скалярного произведения двух векторов.

    Геометрический смысл скалярного произведения двух векторов:
    1. Если скалярное произведение двух векторов положительное, то это означает, что векторы направлены в целом в одну 
    сторону.
    2. Если скалярное произведение двух векторов отрицательное, то это означает, что векторы направлены в целом в 
    противоположные стороны.
    3. Если скалярное произведение двух векторов равно нулю, то это означает, что векторы перпендикулярны.
    
    Метод "getVectorsRelativeDirection()" принимает следующие параметры:
    1. "v1StartPointX" - это числовой параметр, содержащий X-координату начальной точки первого вектора.
    2. "v1StartPointY" - это числовой параметр, содержащий Y-координату начальной точки первого вектора.
    3. "v1EndPointX" - это числовой параметр, содержащий X-координату конечной точки первого вектора.
    4. "v1EndPointY" - это числовой параметр, содержащий Y-координату конечной точки первого вектора.
    5. "v2StartPointX" - это числовой параметр, содержащий X-координату начальной точки второго вектора.
    6. "v2StartPointY" - это числовой параметр, содержащий Y-координату начальной точки второго вектора.
    7. "v2EndPointX" - это числовой параметр, содержащий X-координату конечной точки второго вектора.
    8. "v2EndPointY" - это числовой параметр, содержащий Y-координату конечной точки второго вектора.
    
    Метод "getVectorsRelativeDirection()" возвращает:
    1. 0, как знак того, что векторы перпендикулярны.
    2. 1, как знак того, что векторы направлены в целом в одну сторону.
    3. -1, как знак того, что векторы направлены в целом в противоположные стороны.*/
    getVectorsRelativeDirection: function (
        v1StartPointX, v1StartPointY, v1EndPointX, v1EndPointY,
        v2StartPointX, v2StartPointY, v2EndPointX, v2EndPointY
    ) {
        const dotProduct = this.getDotProduct(
            v1StartPointX, v1StartPointY, v1EndPointX, v1EndPointY,
            v2StartPointX, v2StartPointY, v2EndPointX, v2EndPointY
        );

        /*Создаем переменную "epsilon", которая обозначает символ ε (эпсилон), используемый для обозначения 
        положительного сколь угодно малого вещественного числа. При помощи нее мы устанавливаем порог для учета
        погрешности вычислений.*/
        const epsilon = 1e-12;

        /*Если скалярное произведение двух векторов, учитывая погрешность, равно нулю, то это означает, что векторы 
        перпендикулярны. В этом случае возвращаем 0, как знак того, что векторы перпендикулярны.*/
        if (Math.abs(dotProduct) < epsilon) return 0;
        /*Если скалярное произведение двух векторов, учитывая погрешность, больше нуля, то это означает, что векторы 
        направлены в целом в одну сторону. В этом случае возвращаем 1, как знак того, что векторы направлены в целом в
        одну сторону.*/
        if (dotProduct > 0) return 1;
        /*Если скалярное произведение двух векторов, учитывая погрешность, меньше нуля, то это означает, что векторы 
        направлены в целом в противоположные стороны. В этом случае возвращаем 1, как знак того, что векторы направлены
        в целом в противоположные стороны.*/
        return -1;
    },

    /*Метод "getSquaredVectorLength()" рассчитывает квадрат длины вектора, то есть скалярное произведение двух таких 
    векторов.
    
    Метод "getSquaredVectorLength()" принимает следующие параметры:
    1. "v1StartPointX" - это числовой параметр, содержащий X-координату начальной точки вектора.
    2. "v1StartPointY" - это числовой параметр, содержащий Y-координату начальной точки вектора.
    3. "v1EndPointX" - это числовой параметр, содержащий X-координату конечной точки вектора.
    4. "v1EndPointY" - это числовой параметр, содержащий Y-координату конечной точки вектора.

    Метод "getSquaredVectorLength()" возвращает величину квадрата длины вектора.*/
    getSquaredVectorLength: function (v1StartPointX, v1StartPointY, v1EndPointX, v1EndPointY) {
        return (v1EndPointX - v1StartPointX) * (v1EndPointX - v1StartPointX) +
            (v1EndPointY - v1StartPointY) * (v1EndPointY - v1StartPointY);
    },

    /*Метод "isPointOnLineSegment()" определяет находится ли точка на отрезке.
    
    Метод "isPointOnLineSegment()" принимает следующие параметры:
    1. "startPointX" - это числовой параметр, содержащий X-координату первой точки отрезка.
    2. "startPointY" - это числовой параметр, содержащий Y-координату первой точки отрезка.
    3. "endPointX" - это числовой параметр, содержащий X-координату второй точки отрезка.
    4. "endPointY" - это числовой параметр, содержащий Y-координату второй точки отрезка.
    5. "pointX" - это числовой параметр, содержащий X-координату точки.
    6. "pointY" - это числовой параметр, содержащий Y-координату точки.

    Логика работы метода "isPointOnLineSegment()" следующая:
    1. Проверяем не лежит ли точка за пределами прямой, содержащей отрезок.
    2. Рассчитываем скалярное произведение двух векторов, где первый вектор строится на основе точек отрезка, а второй 
    вектор строится из начальной точки первого вектора в точку, которую проверяем находится ли она на отрезке.
    3. Проверяем не лежит ли точка до первой точки отрезка.
    4. Проверяем не лежит ли точка после второй точки отрезка.
    5. Если все проверки пройдены, то возвращаем true, как знак того, что точка лежит на отрезке.

    Метод "isPointOnLineSegment()" возвращает:
    1. false, как знак того, что точка не лежит на отрезке.
    2. true, как знак того, что точка лежит на отрезке.*/
    isPointOnLineSegment: function (
        startPointX, startPointY, endPointX, endPointY,
        pointX, pointY
    ) {
        /*Проверяем лежит ли точка на прямой, содержащей отрезок, при помощи метода 
        "getPointPositionRelativeToLineSegment()". Если точка не лежит на прямой, содержащей отрезок, то это означает, 
        что она не лежит и на самом отрезке, поэтому дальше нет смысла проводить проверку. Возвращаем false, как знак 
        того, что точка не лежит на отрезке.*/
        if (
            this.getPointPositionRelativeToLineSegment(
                startPointX, startPointY, endPointX, endPointY,
                pointX, pointY
            ) !== 0
        ) {
            return false;
        };

        /*При помощи метода "getDotProduct()" рассчитываем скалярное произведение двух векторов, где первый вектор 
        строится на основе точек отрезка, а второй вектор строится из начальной точки первого вектора в точку, которую 
        проверяем находится ли она на отрезке.*/
        const dotProduct = this.getDotProduct(
            startPointX, startPointY, endPointX, endPointY,
            startPointX, startPointY, pointX, pointY
        );

        /*Создаем переменную "epsilon", которая обозначает символ ε (эпсилон), используемый для обозначения 
        положительного сколь угодно малого вещественного числа. При помощи нее мы устанавливаем порог для учета
        погрешности вычислений.*/
        const epsilon = 1e-12;

        /*Если скалярное произведение двух указанных векторов, учитывая погрешность, меньше 0, то это означает, что эти 
        векторы направлены в целом в разные стороны. А это в свою очередь означает, что наша точка находится до 
        начальной точки первого вектора, то есть за пределами отрезка. Поэтому дальше нет смысла проводить проверку. 
        Возвращаем false, как знак того, что точка не лежит на отрезке.*/
        if (dotProduct < -1 * epsilon) { return false };

        /*Рассчитываем квадрат длины первого вектора при помощи метода "getSquaredVectorLength()".*/
        const squaredLength = this.getSquaredVectorLength(startPointX, startPointY, endPointX, endPointY);

        /*Если два вектора выходят из одной точки и их скалярное произведение больше, чем квадрат длины одного вектора, 
        то это означает, что конечная точка другого вектора дальше конечной точки первого вектора.

        В нашем случае если скалярное произведение двух указанных векторов, выходящих из одной точки, учитывая 
        погрешность, больше квадрата длины первого вектора, то это означает, что наша точка находится дальше конечной 
        точки первого вектора, то есть за пределами отрезка. Поэтому дальше нет смысла проводить проверку. Возвращаем 
        false, как знак того, что точка не лежит на отрезке.*/
        if (dotProduct > squaredLength + epsilon) { return false };

        /*Если все проверки пройдены, то это означает, что точка лежит на отрезке. Возвращаем true, как знак того, что 
        точка лежит на отрезке.*/
        return true;
    },

    /*Метод "doTwoLineSegmentsIntersect()" определяет пересекаются ли два отрезка.
    
    Метод "doTwoLineSegmentsIntersect()" принимает следующие параметры:
    1. "point01" - это параметр в виде объекта, содержащего координаты первой конечной точки первого отрезка.
    2. "point02" - это параметр в виде объекта, содержащего координаты второй конечной точки первого отрезка.
    3. "point03" - это параметр в виде объекта, содержащего координаты первой конечной точки второго отрезка.
    4. "point04" - это параметр в виде объекта, содержащего координаты второй конечной точки второго отрезка.
    
    Логика работы метода "doTwoLineSegmentsIntersect()" следующая:
    1. Определяем положение конечных точек отрезков относительно прямых, содержащих противоположные отрезки.
    2. Проверяем общий случай пересечения двух отрезков, когда конечные точки каждого отрезка лежат по разные стороны 
    относительно прямых, содержащих противоположные отрезки.
    3. Проверяем частные случаи пересечения двух отрезков, когда отрезки касаются конечными точками при помощи метода 
    "helper.isPointOnLineSegment()".
    4. Если ни одна проверка не прошла, то возвращаем false, как знак того, что отрезки не пересекаются.
    
    Метод "doTwoLineSegmentsIntersect()" возвращает:
    1. true, как знак того, что отрезки пересекаются.
    2. false, как знак того, что отрезки не пересекаются.*/
    doTwoLineSegmentsIntersect: function (point01, point02, point03, point04) {
        /*Определяем, где находится конечная точка "point01" относительно прямой, содержащей отрезок "point03-point04", 
        при помощи метода "getPointPositionRelativeToLineSegment()". Результат проверки сохраняем в переменную 
        "point01Orientation".*/
        const point01Orientation = this.getPointPositionRelativeToLineSegment(
            point03.x, point03.y, point04.x, point04.y,
            point01.x, point01.y);

        /*Определяем, где находится конечная точка "point02" относительно прямой, содержащей отрезок "point03-point04", 
        при помощи метода "getPointPositionRelativeToLineSegment()". Результат проверки сохраняем в переменную 
        "point02Orientation".*/
        const point02Orientation = this.getPointPositionRelativeToLineSegment(
            point03.x, point03.y, point04.x, point04.y,
            point02.x, point02.y);

        /*Определяем, где находится конечная точка "point03" относительно прямой, содержащей отрезок "point01-point02", 
        при помощи метода "getPointPositionRelativeToLineSegment()". Результат проверки сохраняем в переменную 
        "point03Orientation".*/
        const point03Orientation = this.getPointPositionRelativeToLineSegment(
            point01.x, point01.y, point02.x, point02.y,
            point03.x, point03.y);

        /*Определяем, где находится конечная точка "point04" относительно прямой, содержащей отрезок "point01-point02", 
        при помощи метода "getPointPositionRelativeToLineSegment()". Результат проверки сохраняем в переменную 
        "point04Orientation".*/
        const point04Orientation = this.getPointPositionRelativeToLineSegment(
            point01.x, point01.y, point02.x, point02.y,
            point04.x, point04.y);

        /*Проверяем общий случай пересечения двух отрезков: два отрезка пересекаются, если конечные точки первого 
        отрезка лежат по разные стороны от прямой, содержащей второй отрезок, а конечные точки второго отрезка лежат по 
        разные стороны от прямой, содержащей первый отрезок. То есть в нашем случае конечные точки "point01" и "point02" 
        должны лежать по разные стороны от отрезка "point03-point04", а конечные точки "point03" и "point04" должны 
        лежать по разные стороны от отрезка "point01-point02". Если это так, то возвращаем true, как знак того, что 
        отрезки пересекаются.*/
        if (
            (point01Orientation * point02Orientation < 0) &&
            (point03Orientation * point04Orientation < 0)
        ) {
            return true;
        };

        /*Проверяем частные случаи пересечения двух отрезков, когда отрезки касаются конечными точками.

        Если точка "point01" лежит на прямой, содержащей отрезок "point03-point04", то при помощи метода 
        "isPointOnLineSegment()" проверяем не лежит ли точка "point01" на самом отрезке "point03-point04". Если это так, 
        то это означает, что отрезок "point01-point02" касается отрезка "point03-point04" точкой "point01". Тогда 
        возвращаем true, как знак того, что отрезки пересекаются.*/
        if (point01Orientation === 0 && this.isPointOnLineSegment(
            point03.x, point03.y, point04.x, point04.y,
            point01.x, point01.y)
        ) { return true };

        /*Если точка "point02" лежит на прямой, содержащей отрезок "point03-point04", то при помощи метода 
        "isPointOnLineSegment()" проверяем не лежит ли точка "point02" на самом отрезке "point03-point04". Если это так, 
        то это означает, что отрезок "point01-point02" касается отрезка "point03-point04" точкой "point02". Тогда 
        возвращаем true, как знак того, что отрезки пересекаются.*/
        if (point02Orientation === 0 && this.isPointOnLineSegment(
            point03.x, point03.y, point04.x, point04.y,
            point02.x, point02.y)
        ) { return true };

        /*Если точка "point03" лежит на прямой, содержащей отрезок "point01-point02", то при помощи метода 
        "isPointOnLineSegment()" проверяем не лежит ли точка "point03" на самом отрезке "point01-point02". Если это так, 
        то это означает, что отрезок "point03-point04" касается отрезка "point01-point02" точкой "point03". Тогда 
        возвращаем true, как знак того, что отрезки пересекаются.*/
        if (point03Orientation === 0 && this.isPointOnLineSegment(
            point01.x, point01.y, point02.x, point02.y,
            point03.x, point03.y)
        ) { return true };

        /*Если точка "point04" лежит на прямой, содержащей отрезок "point01-point02", то при помощи метода 
        "isPointOnLineSegment()" проверяем не лежит ли точка "point04" на самом отрезке "point01-point02". Если это так, 
        то это означает, что отрезок "point03-point04" касается отрезка "point01-point02" точкой "point04". Тогда 
        возвращаем true, как знак того, что отрезки пересекаются.*/
        if (point04Orientation === 0 && this.isPointOnLineSegment(
            point01.x, point01.y, point02.x, point02.y,
            point04.x, point04.y)
        ) { return true };

        /*Если ни одна проверка не прошла, то возвращаем false, как знак того, что отрезки не пересекаются.*/
        return false;
    },

    /*Метод "doTwoPolygonsIntersect()" определяет пересекаются ли два многоугольника.
    
    Метод "doTwoPolygonsIntersect()" принимает следующие параметры:
    1. "vertices01" - это параметр в виде массива объектов, содержащих координаты последовательно указанных вершин 
    первого многоугольника.
    2. "vertices02" - это параметр в виде массива объектов, содержащих координаты последовательно указанных вершин 
    второго многоугольника.
    
    Логика работы метода "doTwoPolygonsIntersect()" следующая:
    1. Избавляемся от дубликатов вершин многоугольников, если таковые имеются.
    2. Перебираем вершины многоугольников и ищем совпадения их вершин.
    3. Перебираем пары соседних вершин каждого многоугольника, чтобы на их основе проверять не пересекаются какие-то
    стороны этих многоугольников.
    4. Если пересечений сторон выявлено не было, то проверяем не находится ли полностью один многоугольник внутри 
    другого многоугольника.
    5. Если ни одна проверка не прошла, то возвращаем false, как знак того, что многоугольники не пересекаются.

    Метод "doTwoPolygonsIntersect()" возвращает:
    1. true, как знак того, что многоугольники пересекаются.
    2. false, как знак того, что многоугольники не пересекаются.*/
    doTwoPolygonsIntersect: function (vertices01, vertices02) {
        /*Избавляемся от дубликатов вершин многоугольников, если таковые имеются, при помощи метода 
        "removeDuplicatesFromPoints()".*/
        vertices01 = this.removeDuplicatesFromPoints(vertices01);
        vertices02 = this.removeDuplicatesFromPoints(vertices02);

        /*Проверяем не совпадают ли какие-нибудь вершины у многоугольников. Если это так, то возвращаем true, как знак 
        того, что многоугольники пересекаются.*/
        for (let i = 0; i < vertices01.length; i++) {
            for (let j = 1; j < vertices02.length; j++) {
                if (
                    vertices01[i].x === vertices02[j].x &&
                    vertices01[i].y === vertices02[j].y
                ) {
                    return true;
                };
            };
        };

        /*Проверяем не пересекаются ли стороны многоугольников. Во внешнем цикле for перебираем пары соседних вершин в 
        первом многоугольнике. Каждая пара вершин будет конечными точками какой-то стороны первого многоугольника.*/
        for (let i = 0; i < vertices01.length; i++) {
            const point01 = vertices01[i];
            /*Чтобы замкнуть многоугольник, используется следующий код: "(i + 1) % vertices01.length". Это позволяет 
            взять следующую вершину, а для последней вершины вернуться к первой. Например, если у нас 6 вершин, то будут
            следующие номера вершин в парах: 
            0 (0 + 1) % 6 = 1 % 6 = 1
            1 (1 + 1) % 6 = 2 % 6 = 2
            2 (2 + 1) % 6 = 3 % 6 = 3
            3 (3 + 1) % 6 = 4 % 6 = 4
            4 (4 + 1) % 6 = 5 % 6 = 5
            5 (5 + 1) % 6 = 6 % 6 = 0*/
            const point02 = vertices01[(i + 1) % vertices01.length];

            /*Во внутреннем цикле for перебираем пары соседних вершин во втором многоугольнике. Каждая пара вершин будет 
            конечными точками какой-то стороны второго многоугольника.*/
            for (let j = 0; j < vertices02.length; j++) {
                const point03 = vertices02[j];
                const point04 = vertices02[(j + 1) % vertices02.length];

                /*Проверяем не пересекаются ли взятые стороны многоугольников при помощи метода 
                "doLineSegmentsIntersect()". Если это так, то возвращаем true, как знак того, что многоугольники
                пересекаются, поскольку если у двух многоугольников пересекаются хотя бы две стороны, то это означает, 
                что и сами многоугольники пересекаются.*/
                if (this.doTwoLineSegmentsIntersect(point01, point02, point03, point04)) { return true };
            };
        };

        /*Если получилось так, что никакие стороны двух многоугольников не пересекаются, то остается два варианта: либо
        многоугольники не пересекаются, либо один многоугольник находится полностью внутри другого многоугольника. 
        Проверяем здесь последнее при помощи метода "isPointInsidePolygon()". Если хотя бы одна вершина одного 
        многоугольника находится внутри другого многоугольника и при этом никакие стороны многоугольников не 
        пересекаются, то это означает, что один многоугольник находится полностью внутри другого многоугольника. Если 
        это так, то возвращаем true, как знак того, что многоугольники пересекаются.*/
        if (
            this.isPointInsidePolygon(vertices01[0], vertices02) ||
            this.isPointInsidePolygon(vertices02[0], vertices01)
        ) {
            return true;
        };

        /*Если ни одна проверка не прошла, то возвращаем false, как знак того, что многоугольники не пересекаются.*/
        return false;
    },

    /*Метод "doTwoPolygonsCoincide()" определяет не совпадают ли два многоугольника.
    
    Метод "doTwoPolygonsCoincide()" принимает следующие параметры:
    1. "vertices01" - это параметр в виде массива объектов, содержащих координаты последовательно указанных вершин 
    первого многоугольника.
    2. "vertices02" - это параметр в виде массива объектов, содержащих координаты последовательно указанных вершин 
    второго многоугольника.

    Метод "doTwoPolygonsCoincide()" возвращает:
    1. true, как знак того, что многоугольники совпадают.
    2. false, как знак того, что многоугольники не совпадают.*/
    doTwoPolygonsCoincide: function (vertices01, vertices02) {
        /*Избавляемся от дубликатов вершин многоугольников, если таковые имеются, при помощи метода 
        "removeDuplicatesFromPoints()".*/
        vertices01 = this.removeDuplicatesFromPoints(vertices01);
        vertices02 = this.removeDuplicatesFromPoints(vertices02);

        /*Проверяем не совпадают ли полностью два многоугольника, если они имеют одинаковое количество вершин. Для этого 
        перебираем все вершины многоугольников и ищем совпадения между ними. Если количество совпадений вершин
        многоугольников равно количеству вершин у каждого из этих многоугольников, то это означает, что эти
        многоугольники полностью совпадают. В этом случае возвращаем true, как знак того, что многоугольники
        пересекаются.*/
        if (vertices01.length === vertices02.length) {
            let coincidentPointsCount = 0;

            for (let i = 0; i < vertices01.length; i++) {
                for (let j = 1; j < vertices02.length; j++) {
                    if (
                        vertices01[i].x === vertices02[j].x &&
                        vertices01[i].y === vertices02[j].y
                    ) {
                        coincidentPointsCount++;
                        break;
                    };
                };
            };

            if (coincidentPointsCount === vertices01.length) { return true };
        } else {
            return false;
        };
    }
};